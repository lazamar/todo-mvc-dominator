// Generated by purs bundle 0.11.7
var PS = {};
(function(exports) {
    "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  var compose = function (dict) {
      return dict.compose;
  };
  exports["compose"] = compose;
  exports["Semigroupoid"] = Semigroupoid;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS["Control.Semigroupoid"] = PS["Control.Semigroupoid"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        
  var Category = function (Semigroupoid0, id) {
      this.Semigroupoid0 = Semigroupoid0;
      this.id = id;
  };
  var id = function (dict) {
      return dict.id;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["Category"] = Category;
  exports["id"] = id;
  exports["categoryFn"] = categoryFn;
})(PS["Control.Category"] = PS["Control.Category"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS["Data.Boolean"] = PS["Data.Boolean"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Category = PS["Control.Category"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
})(PS["Data.Function"] = PS["Data.Function"] || {});
(function(exports) {
    "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function(exports) {
    "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Show"];     
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showInt = new Show($foreign.showIntImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showInt"] = showInt;
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Unit"];
  var Data_Show = PS["Data.Show"];
  exports["unit"] = $foreign.unit;
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Unit = PS["Data.Unit"];        
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };
  var functorFn = new Functor(Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn));
  var functorArray = new Functor($foreign.arrayMap);
  exports["Functor"] = Functor;
  exports["map"] = map;
  exports["functorFn"] = functorFn;
  exports["functorArray"] = functorArray;
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
    "use strict";

  exports.concatString = function (s1) {
    return function (s2) {
      return s1 + s2;
    };
  };

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];        
  var Semigroup = function (append) {
      this.append = append;
  }; 
  var semigroupString = new Semigroup($foreign.concatString);
  var semigroupArray = new Semigroup($foreign.concatArray);
  var append = function (dict) {
      return dict.append;
  };
  exports["Semigroup"] = Semigroup;
  exports["append"] = append;
  exports["semigroupString"] = semigroupString;
  exports["semigroupArray"] = semigroupArray;
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Data_Functor = PS["Data.Functor"];
  var Data_Semigroup = PS["Data.Semigroup"];        
  var Alt = function (Functor0, alt) {
      this.Functor0 = Functor0;
      this.alt = alt;
  };                                                       
  var alt = function (dict) {
      return dict.alt;
  };
  exports["Alt"] = Alt;
  exports["alt"] = alt;
})(PS["Control.Alt"] = PS["Control.Alt"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];        
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  };                      
  var apply = function (dict) {
      return dict.apply;
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS["Control.Applicative"] = PS["Control.Applicative"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  };                     
  var bind = function (dict) {
      return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (v) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (v1) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(v(v1));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS["Control.Monad"] = PS["Control.Monad"] || {});
(function(exports) {
    "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Function = PS["Data.Function"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var Monoid = function (Semigroup0, mempty) {
      this.Semigroup0 = Semigroup0;
      this.mempty = mempty;
  };                 
  var monoidString = new Monoid(function () {
      return Data_Semigroup.semigroupString;
  }, "");  
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["Monoid"] = Monoid;
  exports["mempty"] = mempty;
  exports["monoidString"] = monoidString;
})(PS["Data.Monoid"] = PS["Data.Monoid"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Control.Monad.Eff"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];        
  var monadEff = new Control_Monad.Monad(function () {
      return applicativeEff;
  }, function () {
      return bindEff;
  });
  var bindEff = new Control_Bind.Bind(function () {
      return applyEff;
  }, $foreign.bindE);
  var applyEff = new Control_Apply.Apply(function () {
      return functorEff;
  }, Control_Monad.ap(monadEff));
  var applicativeEff = new Control_Applicative.Applicative(function () {
      return applyEff;
  }, $foreign.pureE);
  var functorEff = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEff));
  exports["functorEff"] = functorEff;
  exports["applyEff"] = applyEff;
  exports["applicativeEff"] = applicativeEff;
  exports["bindEff"] = bindEff;
  exports["monadEff"] = monadEff;
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Category = PS["Control.Category"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];        
  var MonadEff = function (Monad0, liftEff) {
      this.Monad0 = Monad0;
      this.liftEff = liftEff;
  };
  var monadEffEff = new MonadEff(function () {
      return Control_Monad_Eff.monadEff;
  }, Control_Category.id(Control_Category.categoryFn));
  var liftEff = function (dict) {
      return dict.liftEff;
  };
  exports["liftEff"] = liftEff;
  exports["MonadEff"] = MonadEff;
  exports["monadEffEff"] = monadEffEff;
})(PS["Control.Monad.Eff.Class"] = PS["Control.Monad.Eff.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Prelude = PS["Prelude"];        
  var MonadTrans = function (lift) {
      this.lift = lift;
  };
  var lift = function (dict) {
      return dict.lift;
  };
  exports["lift"] = lift;
  exports["MonadTrans"] = MonadTrans;
})(PS["Control.Monad.Trans.Class"] = PS["Control.Monad.Trans.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Prelude = PS["Prelude"];        
  var Newtype = function (unwrap, wrap) {
      this.unwrap = unwrap;
      this.wrap = wrap;
  };
  var wrap = function (dict) {
      return dict.wrap;
  };
  var unwrap = function (dict) {
      return dict.unwrap;
  };
  var alaF = function (dictFunctor) {
      return function (dictFunctor1) {
          return function (dictNewtype) {
              return function (dictNewtype1) {
                  return function (v) {
                      return function (f) {
                          return function ($64) {
                              return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(wrap(dictNewtype))($64)));
                          };
                      };
                  };
              };
          };
      };
  };
  exports["unwrap"] = unwrap;
  exports["wrap"] = wrap;
  exports["Newtype"] = Newtype;
  exports["alaF"] = alaF;
})(PS["Data.Newtype"] = PS["Data.Newtype"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Newtype = PS["Data.Newtype"];
  var Prelude = PS["Prelude"];
  var monadTransContT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function (m) {
          return function (k) {
              return Control_Bind.bind(dictMonad.Bind1())(m)(k);
          };
      };
  });
  var functorContT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return function (k) {
                  return v(function (a) {
                      return k(f(a));
                  });
              };
          };
      });
  };
  var applyContT = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorContT(dictApply.Functor0());
      }, function (v) {
          return function (v1) {
              return function (k) {
                  return v(function (g) {
                      return v1(function (a) {
                          return k(g(a));
                      });
                  });
              };
          };
      });
  };
  var bindContT = function (dictBind) {
      return new Control_Bind.Bind(function () {
          return applyContT(dictBind.Apply0());
      }, function (v) {
          return function (k) {
              return function (k$prime) {
                  return v(function (a) {
                      var v1 = k(a);
                      return v1(k$prime);
                  });
              };
          };
      });
  };
  var applicativeContT = function (dictApplicative) {
      return new Control_Applicative.Applicative(function () {
          return applyContT(dictApplicative.Apply0());
      }, function (a) {
          return function (k) {
              return k(a);
          };
      });
  };
  var monadContT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeContT(dictMonad.Applicative0());
      }, function () {
          return bindContT(dictMonad.Bind1());
      });
  };
  var monadEffContT = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadContT(dictMonadEff.Monad0());
      }, function ($46) {
          return Control_Monad_Trans_Class.lift(monadTransContT)(dictMonadEff.Monad0())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($46));
      });
  };
  exports["functorContT"] = functorContT;
  exports["applyContT"] = applyContT;
  exports["applicativeContT"] = applicativeContT;
  exports["bindContT"] = bindContT;
  exports["monadContT"] = monadContT;
  exports["monadTransContT"] = monadTransContT;
  exports["monadEffContT"] = monadEffContT;
})(PS["Control.Monad.Cont.Trans"] = PS["Control.Monad.Cont.Trans"] || {});
(function(exports) {
    "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Data_Functor = PS["Data.Functor"];        
  var Plus = function (Alt0, empty) {
      this.Alt0 = Alt0;
      this.empty = empty;
  };       
  var empty = function (dict) {
      return dict.empty;
  };
  exports["Plus"] = Plus;
  exports["empty"] = empty;
})(PS["Control.Plus"] = PS["Control.Plus"] || {});
(function(exports) {
    "use strict";

  exports.boolConj = function (b1) {
    return function (b2) {
      return b1 && b2;
    };
  };

  exports.boolDisj = function (b1) {
    return function (b2) {
      return b1 || b2;
    };
  };

  exports.boolNot = function (b) {
    return !b;
  };
})(PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.HeytingAlgebra"];
  var Data_Unit = PS["Data.Unit"];        
  var HeytingAlgebra = function (conj, disj, ff, implies, not, tt) {
      this.conj = conj;
      this.disj = disj;
      this.ff = ff;
      this.implies = implies;
      this.not = not;
      this.tt = tt;
  };
  var tt = function (dict) {
      return dict.tt;
  };
  var not = function (dict) {
      return dict.not;
  };
  var implies = function (dict) {
      return dict.implies;
  };                 
  var ff = function (dict) {
      return dict.ff;
  };
  var disj = function (dict) {
      return dict.disj;
  };
  var heytingAlgebraBoolean = new HeytingAlgebra($foreign.boolConj, $foreign.boolDisj, false, function (a) {
      return function (b) {
          return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
      };
  }, $foreign.boolNot, true);
  var conj = function (dict) {
      return dict.conj;
  };
  exports["HeytingAlgebra"] = HeytingAlgebra;
  exports["tt"] = tt;
  exports["ff"] = ff;
  exports["implies"] = implies;
  exports["conj"] = conj;
  exports["disj"] = disj;
  exports["not"] = not;
  exports["heytingAlgebraBoolean"] = heytingAlgebraBoolean;
})(PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe line 219, column 1 - line 219, column 51: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };                                                      
  var functorMaybe = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Just) {
              return new Just(v(v1.value0));
          };
          return Nothing.value;
      };
  });
  var applyMaybe = new Control_Apply.Apply(function () {
      return functorMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return Data_Functor.map(functorMaybe)(v.value0)(v1);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe line 68, column 1 - line 68, column 35: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var applicativeMaybe = new Control_Applicative.Applicative(function () {
      return applyMaybe;
  }, Just.create);
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["maybe"] = maybe;
  exports["functorMaybe"] = functorMaybe;
  exports["applyMaybe"] = applyMaybe;
  exports["applicativeMaybe"] = applicativeMaybe;
})(PS["Data.Maybe"] = PS["Data.Maybe"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Prelude = PS["Prelude"];        
  var Conj = function (x) {
      return x;
  };
  var semigroupConj = function (dictHeytingAlgebra) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);
          };
      });
  };
  var newtypeConj = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Conj);
  var monoidConj = function (dictHeytingAlgebra) {
      return new Data_Monoid.Monoid(function () {
          return semigroupConj(dictHeytingAlgebra);
      }, Data_HeytingAlgebra.tt(dictHeytingAlgebra));
  };
  exports["Conj"] = Conj;
  exports["newtypeConj"] = newtypeConj;
  exports["semigroupConj"] = semigroupConj;
  exports["monoidConj"] = monoidConj;
})(PS["Data.Monoid.Conj"] = PS["Data.Monoid.Conj"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Foldable"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Endo = PS["Data.Monoid.Endo"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var foldl = function (dict) {
      return dict.foldl;
  };
  var intercalate = function (dictFoldable) {
      return function (dictMonoid) {
          return function (sep) {
              return function (xs) {
                  var go = function (v) {
                      return function (x) {
                          if (v.init) {
                              return {
                                  init: false,
                                  acc: x
                              };
                          };
                          return {
                              init: false,
                              acc: Data_Semigroup.append(dictMonoid.Semigroup0())(v.acc)(Data_Semigroup.append(dictMonoid.Semigroup0())(sep)(x))
                          };
                      };
                  };
                  return (foldl(dictFoldable)(go)({
                      init: true,
                      acc: Data_Monoid.mempty(dictMonoid)
                  })(xs)).acc;
              };
          };
      };
  }; 
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  var all = function (dictFoldable) {
      return function (dictHeytingAlgebra) {
          return Data_Newtype.alaF(Data_Functor.functorFn)(Data_Functor.functorFn)(Data_Monoid_Conj.newtypeConj)(Data_Monoid_Conj.newtypeConj)(Data_Monoid_Conj.Conj)(foldMap(dictFoldable)(Data_Monoid_Conj.monoidConj(dictHeytingAlgebra)));
      };
  };
  exports["Foldable"] = Foldable;
  exports["foldr"] = foldr;
  exports["foldl"] = foldl;
  exports["foldMap"] = foldMap;
  exports["foldMapDefaultR"] = foldMapDefaultR;
  exports["intercalate"] = intercalate;
  exports["all"] = all;
  exports["foldableArray"] = foldableArray;
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Prelude = PS["Prelude"];        
  var Left = (function () {
      function Left(value0) {
          this.value0 = value0;
      };
      Left.create = function (value0) {
          return new Left(value0);
      };
      return Left;
  })();
  var Right = (function () {
      function Right(value0) {
          this.value0 = value0;
      };
      Right.create = function (value0) {
          return new Right(value0);
      };
      return Right;
  })();
  var functorEither = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Left) {
              return new Left(v1.value0);
          };
          if (v1 instanceof Right) {
              return new Right(v(v1.value0));
          };
          throw new Error("Failed pattern match at Data.Either line 36, column 1 - line 36, column 45: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var either = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return v(v2.value0);
              };
              if (v2 instanceof Right) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Either line 229, column 1 - line 229, column 64: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  }; 
  var applyEither = new Control_Apply.Apply(function () {
      return functorEither;
  }, function (v) {
      return function (v1) {
          if (v instanceof Left) {
              return new Left(v.value0);
          };
          if (v instanceof Right) {
              return Data_Functor.map(functorEither)(v.value0)(v1);
          };
          throw new Error("Failed pattern match at Data.Either line 79, column 1 - line 79, column 41: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var applicativeEither = new Control_Applicative.Applicative(function () {
      return applyEither;
  }, Right.create);
  exports["Left"] = Left;
  exports["Right"] = Right;
  exports["either"] = either;
  exports["functorEither"] = functorEither;
  exports["applyEither"] = applyEither;
  exports["applicativeEither"] = applicativeEither;
})(PS["Data.Either"] = PS["Data.Either"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Either = PS["Data.Either"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var MonadThrow = function (Monad0, throwError) {
      this.Monad0 = Monad0;
      this.throwError = throwError;
  };
  var throwError = function (dict) {
      return dict.throwError;
  };
  exports["throwError"] = throwError;
  exports["MonadThrow"] = MonadThrow;
})(PS["Control.Monad.Error.Class"] = PS["Control.Monad.Error.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Distributive = PS["Data.Distributive"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var Type_Equality = PS["Type.Equality"];        
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  var snd = function (v) {
      return v.value1;
  };                                                                                                    
  var fst = function (v) {
      return v.value0;
  };
  exports["Tuple"] = Tuple;
  exports["fst"] = fst;
  exports["snd"] = snd;
})(PS["Data.Tuple"] = PS["Data.Tuple"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Either = PS["Data.Either"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Tuple = PS["Data.Tuple"];
  var Prelude = PS["Prelude"];        
  var ExceptT = function (x) {
      return x;
  };
  var runExceptT = function (v) {
      return v;
  }; 
  var mapExceptT = function (f) {
      return function (v) {
          return f(v);
      };
  };
  var functorExceptT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return mapExceptT(Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Either.functorEither)(f)));
      });
  };
  var monadExceptT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeExceptT(dictMonad);
      }, function () {
          return bindExceptT(dictMonad);
      });
  };
  var bindExceptT = function (dictMonad) {
      return new Control_Bind.Bind(function () {
          return applyExceptT(dictMonad);
      }, function (v) {
          return function (k) {
              return Control_Bind.bind(dictMonad.Bind1())(v)(Data_Either.either(function ($97) {
                  return Control_Applicative.pure(dictMonad.Applicative0())(Data_Either.Left.create($97));
              })(function (a) {
                  var v1 = k(a);
                  return v1;
              }));
          };
      });
  };
  var applyExceptT = function (dictMonad) {
      return new Control_Apply.Apply(function () {
          return functorExceptT(((dictMonad.Bind1()).Apply0()).Functor0());
      }, Control_Monad.ap(monadExceptT(dictMonad)));
  };
  var applicativeExceptT = function (dictMonad) {
      return new Control_Applicative.Applicative(function () {
          return applyExceptT(dictMonad);
      }, function ($98) {
          return ExceptT(Control_Applicative.pure(dictMonad.Applicative0())(Data_Either.Right.create($98)));
      });
  };
  var monadThrowExceptT = function (dictMonad) {
      return new Control_Monad_Error_Class.MonadThrow(function () {
          return monadExceptT(dictMonad);
      }, function ($102) {
          return ExceptT(Control_Applicative.pure(dictMonad.Applicative0())(Data_Either.Left.create($102)));
      });
  };
  exports["ExceptT"] = ExceptT;
  exports["runExceptT"] = runExceptT;
  exports["mapExceptT"] = mapExceptT;
  exports["functorExceptT"] = functorExceptT;
  exports["applyExceptT"] = applyExceptT;
  exports["applicativeExceptT"] = applicativeExceptT;
  exports["bindExceptT"] = bindExceptT;
  exports["monadExceptT"] = monadExceptT;
  exports["monadThrowExceptT"] = monadThrowExceptT;
})(PS["Control.Monad.Except.Trans"] = PS["Control.Monad.Except.Trans"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad = PS["Control.Monad"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Field = PS["Data.Field"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Prelude = PS["Prelude"];        
  var Identity = function (x) {
      return x;
  };
  var newtypeIdentity = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Identity);
  var functorIdentity = new Data_Functor.Functor(function (f) {
      return function (v) {
          return f(v);
      };
  });
  var applyIdentity = new Control_Apply.Apply(function () {
      return functorIdentity;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var bindIdentity = new Control_Bind.Bind(function () {
      return applyIdentity;
  }, function (v) {
      return function (f) {
          return f(v);
      };
  });
  var applicativeIdentity = new Control_Applicative.Applicative(function () {
      return applyIdentity;
  }, Identity);
  var monadIdentity = new Control_Monad.Monad(function () {
      return applicativeIdentity;
  }, function () {
      return bindIdentity;
  });
  exports["Identity"] = Identity;
  exports["newtypeIdentity"] = newtypeIdentity;
  exports["functorIdentity"] = functorIdentity;
  exports["applyIdentity"] = applyIdentity;
  exports["applicativeIdentity"] = applicativeIdentity;
  exports["bindIdentity"] = bindIdentity;
  exports["monadIdentity"] = monadIdentity;
})(PS["Data.Identity"] = PS["Data.Identity"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Either = PS["Data.Either"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Prelude = PS["Prelude"];                                                           
  var runExcept = function ($0) {
      return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(Control_Monad_Except_Trans.runExceptT($0));
  };
  var mapExcept = function (f) {
      return Control_Monad_Except_Trans.mapExceptT(function ($1) {
          return Data_Identity.Identity(f(Data_Newtype.unwrap(Data_Identity.newtypeIdentity)($1)));
      });
  };
  exports["runExcept"] = runExcept;
  exports["mapExcept"] = mapExcept;
})(PS["Control.Monad.Except"] = PS["Control.Monad.Except"] || {});
(function(exports) {
    "use strict";       

  exports.fromFoldableImpl = (function () {
    function Cons(head, tail) {
      this.head = head;
      this.tail = tail;
    }
    var emptyList = {};

    function curryCons(head) {
      return function (tail) {
        return new Cons(head, tail);
      };
    }

    function listToArray(list) {
      var result = [];
      var count = 0;
      var xs = list;
      while (xs !== emptyList) {
        result[count++] = xs.head;
        xs = xs.tail;
      }
      return result;
    }

    return function (foldr) {
      return function (xs) {
        return listToArray(foldr(curryCons)(emptyList)(xs));
      };
    };
  })();

  exports.filter = function (f) {
    return function (xs) {
      return xs.filter(f);
    };
  };
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_FoldableWithIndex = PS["Data.FoldableWithIndex"];
  var Data_Functor = PS["Data.Functor"];
  var Data_FunctorWithIndex = PS["Data.FunctorWithIndex"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = PS["Data.Semigroup.Foldable"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_TraversableWithIndex = PS["Data.TraversableWithIndex"];
  var Prelude = PS["Prelude"];        
  var NonEmpty = (function () {
      function NonEmpty(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      NonEmpty.create = function (value0) {
          return function (value1) {
              return new NonEmpty(value0, value1);
          };
      };
      return NonEmpty;
  })();
  var singleton = function (dictPlus) {
      return function (a) {
          return new NonEmpty(a, Control_Plus.empty(dictPlus));
      };
  };
  exports["NonEmpty"] = NonEmpty;
  exports["singleton"] = singleton;
})(PS["Data.NonEmpty"] = PS["Data.NonEmpty"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Array"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Array_ST = PS["Data.Array.ST"];
  var Data_Array_ST_Iterator = PS["Data.Array.ST.Iterator"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];
  var fromFoldable = function (dictFoldable) {
      return $foreign.fromFoldableImpl(Data_Foldable.foldr(dictFoldable));
  };
  exports["fromFoldable"] = fromFoldable;
  exports["filter"] = $foreign.filter;
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
    "use strict";

  exports.toForeign = function (value) {
    return value;
  };

  exports.unsafeFromForeign = function (value) {
    return value;
  };

  exports.typeOf = function (value) {
    return typeof value;
  };

  exports.tagOf = function (value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  };

  exports.isNull = function (value) {
    return value === null;
  };

  exports.isUndefined = function (value) {
    return value === undefined;
  };
})(PS["Data.Foreign"] = PS["Data.Foreign"] || {});
(function(exports) {
    "use strict";

  // module Data.Int

  exports.fromNumberImpl = function (just) {
    return function (nothing) {
      return function (n) {
        /* jshint bitwise: false */
        return (n | 0) === n ? just(n) : nothing;
      };
    };
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Int"];
  var Control_Category = PS["Control.Category"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_DivisionRing = PS["Data.DivisionRing"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Field = PS["Data.Field"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Int_Bits = PS["Data.Int.Bits"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Global = PS["Global"];
  var $$Math = PS["Math"];
  var Prelude = PS["Prelude"];      
  var fromNumber = $foreign.fromNumberImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  exports["fromNumber"] = fromNumber;
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_FoldableWithIndex = PS["Data.FoldableWithIndex"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_FunctorWithIndex = PS["Data.FunctorWithIndex"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = PS["Data.Semigroup.Foldable"];
  var Data_Semigroup_Traversable = PS["Data.Semigroup.Traversable"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_TraversableWithIndex = PS["Data.TraversableWithIndex"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];        
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var NonEmptyList = function (x) {
      return x;
  };
  var foldableList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return Data_Foldable.foldl(foldableList)(function (acc) {
              return function ($158) {
                  return Data_Semigroup.append(dictMonoid.Semigroup0())(acc)(f($158));
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  }, function (f) {
      var go = function ($copy_b) {
          return function ($copy_v) {
              var $tco_var_b = $copy_b;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(b, v) {
                  if (v instanceof Nil) {
                      $tco_done = true;
                      return b;
                  };
                  if (v instanceof Cons) {
                      $tco_var_b = f(b)(v.value0);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List.Types line 81, column 12 - line 83, column 30: " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_b, $copy_v);
              };
              return $tco_result;
          };
      };
      return go;
  }, function (f) {
      return function (b) {
          var rev = Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value);
          return function ($159) {
              return Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b)(rev($159));
          };
      };
  });
  var functorList = new Data_Functor.Functor(function (f) {
      return Data_Foldable.foldr(foldableList)(function (x) {
          return function (acc) {
              return new Cons(f(x), acc);
          };
      })(Nil.value);
  });
  var semigroupList = new Data_Semigroup.Semigroup(function (xs) {
      return function (ys) {
          return Data_Foldable.foldr(foldableList)(Cons.create)(ys)(xs);
      };
  });
  var monoidList = new Data_Monoid.Monoid(function () {
      return semigroupList;
  }, Nil.value);                                   
  var altList = new Control_Alt.Alt(function () {
      return functorList;
  }, Data_Semigroup.append(semigroupList));
  var plusList = new Control_Plus.Plus(function () {
      return altList;
  }, Nil.value);
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["NonEmptyList"] = NonEmptyList;
  exports["semigroupList"] = semigroupList;
  exports["monoidList"] = monoidList;
  exports["functorList"] = functorList;
  exports["foldableList"] = foldableList;
  exports["altList"] = altList;
  exports["plusList"] = plusList;
})(PS["Data.List.Types"] = PS["Data.List.Types"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_FunctorWithIndex = PS["Data.FunctorWithIndex"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var reverse = (function () {
      var go = function ($copy_acc) {
          return function ($copy_v) {
              var $tco_var_acc = $copy_acc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(acc, v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return acc;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List line 368, column 3 - line 368, column 19: " + [ acc.constructor.name, v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_acc, $copy_v);
              };
              return $tco_result;
          };
      };
      return go(Data_List_Types.Nil.value);
  })();
  var $$null = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return true;
      };
      return false;
  };
  var length = Data_Foldable.foldl(Data_List_Types.foldableList)(function (acc) {
      return function (v) {
          return acc + 1 | 0;
      };
  })(0);
  var fromFoldable = function (dictFoldable) {
      return Data_Foldable.foldr(dictFoldable)(Data_List_Types.Cons.create)(Data_List_Types.Nil.value);
  };
  var filter = function (p) {
      var go = function ($copy_acc) {
          return function ($copy_v) {
              var $tco_var_acc = $copy_acc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(acc, v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return reverse(acc);
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (p(v.value0)) {
                          $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);
                          $copy_v = v.value1;
                          return;
                      };
                      if (Data_Boolean.otherwise) {
                          $tco_var_acc = acc;
                          $copy_v = v.value1;
                          return;
                      };
                  };
                  throw new Error("Failed pattern match at Data.List line 390, column 3 - line 390, column 27: " + [ acc.constructor.name, v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_acc, $copy_v);
              };
              return $tco_result;
          };
      };
      return go(Data_List_Types.Nil.value);
  };
  exports["fromFoldable"] = fromFoldable;
  exports["null"] = $$null;
  exports["length"] = length;
  exports["reverse"] = reverse;
  exports["filter"] = filter;
})(PS["Data.List"] = PS["Data.List"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = PS["Data.Semigroup.Foldable"];
  var Data_Semigroup_Traversable = PS["Data.Semigroup.Traversable"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];
  var singleton = function ($160) {
      return Data_List_Types.NonEmptyList(Data_NonEmpty.singleton(Data_List_Types.plusList)($160));
  };
  exports["singleton"] = singleton;
})(PS["Data.List.NonEmpty"] = PS["Data.List.NonEmpty"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.String"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_String_Unsafe = PS["Data.String.Unsafe"];
  var Prelude = PS["Prelude"];
  var $$null = function (s) {
      return s === "";
  };
  exports["null"] = $$null;
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Foreign"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Either = PS["Data.Either"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Int = PS["Data.Int"];
  var Data_List_NonEmpty = PS["Data.List.NonEmpty"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_String = PS["Data.String"];
  var Prelude = PS["Prelude"];        
  var ForeignError = (function () {
      function ForeignError(value0) {
          this.value0 = value0;
      };
      ForeignError.create = function (value0) {
          return new ForeignError(value0);
      };
      return ForeignError;
  })();
  var TypeMismatch = (function () {
      function TypeMismatch(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      TypeMismatch.create = function (value0) {
          return function (value1) {
              return new TypeMismatch(value0, value1);
          };
      };
      return TypeMismatch;
  })();
  var readNullOrUndefined = function (value) {
      if ($foreign.isNull(value) || $foreign.isUndefined(value)) {
          return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))(Data_Maybe.Nothing.value);
      };
      if (Data_Boolean.otherwise) {
          return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))(new Data_Maybe.Just(value));
      };
      throw new Error("Failed pattern match at Data.Foreign line 160, column 1 - line 160, column 52: " + [ value.constructor.name ]);
  };
  var fail = function ($121) {
      return Control_Monad_Error_Class.throwError(Control_Monad_Except_Trans.monadThrowExceptT(Data_Identity.monadIdentity))(Data_List_NonEmpty.singleton($121));
  };
  var unsafeReadTagged = function (tag) {
      return function (value) {
          if ($foreign.tagOf(value) === tag) {
              return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))($foreign.unsafeFromForeign(value));
          };
          if (Data_Boolean.otherwise) {
              return fail(new TypeMismatch(tag, $foreign.tagOf(value)));
          };
          throw new Error("Failed pattern match at Data.Foreign line 104, column 1 - line 104, column 55: " + [ tag.constructor.name, value.constructor.name ]);
      };
  };                                            
  var readNumber = unsafeReadTagged("Number");
  var readInt = function (value) {
      var error = Data_Either.Left.create(Data_List_NonEmpty.singleton(new TypeMismatch("Int", $foreign.tagOf(value))));
      var fromNumber = function ($122) {
          return Data_Maybe.maybe(error)(Control_Applicative.pure(Data_Either.applicativeEither))(Data_Int.fromNumber($122));
      };
      return Control_Monad_Except.mapExcept(Data_Either.either(Data_Function["const"](error))(fromNumber))(readNumber(value));
  };
  var readString = unsafeReadTagged("String");
  exports["ForeignError"] = ForeignError;
  exports["TypeMismatch"] = TypeMismatch;
  exports["unsafeReadTagged"] = unsafeReadTagged;
  exports["readString"] = readString;
  exports["readNumber"] = readNumber;
  exports["readInt"] = readInt;
  exports["readNullOrUndefined"] = readNullOrUndefined;
  exports["fail"] = fail;
  exports["toForeign"] = $foreign.toForeign;
  exports["unsafeFromForeign"] = $foreign.unsafeFromForeign;
  exports["typeOf"] = $foreign.typeOf;
})(PS["Data.Foreign"] = PS["Data.Foreign"] || {});
(function(exports) {
    "use strict";

  exports.unsafeReadPropImpl = function (f, s, key, value) {
    return value == null ? f : s(value[key]);
  };
})(PS["Data.Foreign.Index"] = PS["Data.Foreign.Index"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Foreign.Index"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Function = PS["Data.Function"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Identity = PS["Data.Identity"];
  var Data_List_NonEmpty = PS["Data.List.NonEmpty"];
  var Prelude = PS["Prelude"];
  var unsafeReadProp = function (k) {
      return function (value) {
          return $foreign.unsafeReadPropImpl(Data_Foreign.fail(new Data_Foreign.TypeMismatch("object", Data_Foreign.typeOf(value))), Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)), k, value);
      };
  };
  var readProp = unsafeReadProp;
  exports["readProp"] = readProp;
})(PS["Data.Foreign.Index"] = PS["Data.Foreign.Index"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Prelude = PS["Prelude"];
  var $$Proxy = (function () {
      function $$Proxy() {

      };
      $$Proxy.value = new $$Proxy();
      return $$Proxy;
  })();
  exports["Proxy"] = $$Proxy;
})(PS["Type.Proxy"] = PS["Type.Proxy"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Generic"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Array = PS["Data.Array"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Either = PS["Data.Either"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Identity = PS["Data.Identity"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_String = PS["Data.String"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];
  var Prelude = PS["Prelude"];
  var Type_Proxy = PS["Type.Proxy"];        
  var SProd = (function () {
      function SProd(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      SProd.create = function (value0) {
          return function (value1) {
              return new SProd(value0, value1);
          };
      };
      return SProd;
  })();
  var SRecord = (function () {
      function SRecord(value0) {
          this.value0 = value0;
      };
      SRecord.create = function (value0) {
          return new SRecord(value0);
      };
      return SRecord;
  })();
  var SBoolean = (function () {
      function SBoolean(value0) {
          this.value0 = value0;
      };
      SBoolean.create = function (value0) {
          return new SBoolean(value0);
      };
      return SBoolean;
  })();
  var SInt = (function () {
      function SInt(value0) {
          this.value0 = value0;
      };
      SInt.create = function (value0) {
          return new SInt(value0);
      };
      return SInt;
  })();
  var SString = (function () {
      function SString(value0) {
          this.value0 = value0;
      };
      SString.create = function (value0) {
          return new SString(value0);
      };
      return SString;
  })();
  var SigProd = (function () {
      function SigProd(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      SigProd.create = function (value0) {
          return function (value1) {
              return new SigProd(value0, value1);
          };
      };
      return SigProd;
  })();
  var SigRecord = (function () {
      function SigRecord(value0) {
          this.value0 = value0;
      };
      SigRecord.create = function (value0) {
          return new SigRecord(value0);
      };
      return SigRecord;
  })();
  var SigBoolean = (function () {
      function SigBoolean() {

      };
      SigBoolean.value = new SigBoolean();
      return SigBoolean;
  })();
  var SigInt = (function () {
      function SigInt() {

      };
      SigInt.value = new SigInt();
      return SigInt;
  })();
  var SigString = (function () {
      function SigString() {

      };
      SigString.value = new SigString();
      return SigString;
  })();
  var Generic = function (fromSpine, toSignature, toSpine) {
      this.fromSpine = fromSpine;
      this.toSignature = toSignature;
      this.toSpine = toSpine;
  };
  var toSpine = function (dict) {
      return dict.toSpine;
  };
  var toSignature = function (dict) {
      return dict.toSignature;
  }; 
  var genericString = new Generic(function (v) {
      if (v instanceof SString) {
          return new Data_Maybe.Just(v.value0);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigString.value;
  }, SString.create);
  var genericInt = new Generic(function (v) {
      if (v instanceof SInt) {
          return new Data_Maybe.Just(v.value0);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigInt.value;
  }, SInt.create); 
  var genericBool = new Generic(function (v) {
      if (v instanceof SBoolean) {
          return new Data_Maybe.Just(v.value0);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigBoolean.value;
  }, SBoolean.create);
  var fromSpine = function (dict) {
      return dict.fromSpine;
  };
  var force = function (f) {
      return f(Data_Unit.unit);
  };
  var genericList = function (dictGeneric) {
      return new Generic(function (v) {
          if (v instanceof SProd && (v.value0 === "Data.List.Types.Cons" && v.value1.length === 2)) {
              return Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(Data_List_Types.Cons.create)(fromSpine(dictGeneric)(force(v["value1"][0]))))(fromSpine(genericList(dictGeneric))(force(v["value1"][1])));
          };
          if (v instanceof SProd && (v.value0 === "Data.List.Types.Nil" && v.value1.length === 0)) {
              return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(Data_List_Types.Nil.value);
          };
          return Data_Maybe.Nothing.value;
      }, function (x) {
          var headProxy = function (v) {
              return Type_Proxy["Proxy"].value;
          };
          return new SigProd("Data.List.Types.List", [ {
              sigConstructor: "Data.List.Types.Cons",
              sigValues: [ function (v) {
                  return toSignature(dictGeneric)(headProxy(x));
              }, function (v) {
                  return toSignature(genericList(dictGeneric))(x);
              } ]
          }, {
              sigConstructor: "Data.List.Types.Nil",
              sigValues: [  ]
          } ]);
      }, function (v) {
          if (v instanceof Data_List_Types.Cons) {
              return new SProd("Data.List.Types.Cons", [ function (v1) {
                  return toSpine(dictGeneric)(v.value0);
              }, function (v1) {
                  return toSpine(genericList(dictGeneric))(v.value1);
              } ]);
          };
          if (v instanceof Data_List_Types.Nil) {
              return new SProd("Data.List.Types.Nil", [  ]);
          };
          throw new Error("Failed pattern match at Data.Generic line 116, column 1 - line 116, column 58: " + [ v.constructor.name ]);
      });
  };
  exports["Generic"] = Generic;
  exports["toSpine"] = toSpine;
  exports["toSignature"] = toSignature;
  exports["fromSpine"] = fromSpine;
  exports["SProd"] = SProd;
  exports["SRecord"] = SRecord;
  exports["SBoolean"] = SBoolean;
  exports["SInt"] = SInt;
  exports["SString"] = SString;
  exports["SigProd"] = SigProd;
  exports["SigRecord"] = SigRecord;
  exports["SigBoolean"] = SigBoolean;
  exports["SigInt"] = SigInt;
  exports["SigString"] = SigString;
  exports["genericInt"] = genericInt;
  exports["genericString"] = genericString;
  exports["genericBool"] = genericBool;
  exports["genericList"] = genericList;
})(PS["Data.Generic"] = PS["Data.Generic"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Function = PS["Data.Function"];
  var Data_Identity = PS["Data.Identity"];
  var Prelude = PS["Prelude"];        
  var succeed = function (v) {
      return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))(v);
  };
  var fail = function (reason) {
      return Data_Foreign.fail(new Data_Foreign.ForeignError(reason));
  };
  exports["succeed"] = succeed;
  exports["fail"] = fail;
})(PS["Dominator.Decode"] = PS["Dominator.Decode"] || {});
(function(exports) {/* eslint-disable no-use-before-define */

  function F6(fn) {
      return function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return fn(a, b, c, d, e, f);
                          };
                      };
                  };
              };
          };
      };
  }

  function runOnce(fn) {
      var called = false;
      return function() {
          if (called) {
              return;
          }
          called = true;
          return fn.apply(null, arguments);
      };
  }

  function dispatchCmds(cmds, enqueue) {
      var i;
      var length = cmds.length;
      for (i = 0; i < length; i++) {
          var f = cmds[i];
          var run = function() {
              f(runOnce(enqueue))();
          };

          setTimeout(run, 0);
      }
  }

  function program(maybeParentNode, scheduler, normalRenderer, init, update, view) {
      // -- create renderer --

      return function() {
          var parentNode =
              maybeParentNode.constructor.name === "Just" ? maybeParentNode.value0 : document.body;

          var initialModel = init.value0;
          var initialCmds = init.value1;

          var renderer = normalRenderer(parentNode, view);
          var updateView = renderer(enqueue, initialModel);
          // ---------------------
          var model = initialModel;

          function onMessage(msg) {
              var tup = update(msg)(model);
              model = tup.value0;
              var cmds = tup.value1;
              updateView(model);
              dispatchCmds(cmds, enqueue);
          }

          var mainProcess = scheduler.spawn(onMessage);
          dispatchCmds(initialCmds, enqueue);

          function enqueue(msg) {
              scheduler.send(mainProcess, msg);
              return function() {};
          }
      };
  }

  exports.program = F6(program);
})(PS["Dominator.Native.Platform"] = PS["Dominator.Native.Platform"] || {});
(function(exports) {/* eslint-disable no-use-before-define, complexity */

  var scheduler = (function() {
      var working = false;
      var workQueue = [];
      var pid = 0;

      // Maximum number of times that we will run entire updates
      // consecutively. If we hit the max it means that we are
      // propbably in a loop
      var MAX_STEPS = 10000;

      // Create a process
      function spawn(onMessage) {
          var process = {
              id: ++pid,
              onMessage: onMessage,
              messageQueue: []
          };

          return process;
      }

      // Send a msg to a process
      function send(process, msg) {
          process.messageQueue.push(msg);
          enqueue(process);
      }

      function enqueue(msg) {
          workQueue.push(msg);

          if (!working) {
              setTimeout(work, 0);
              working = true;
          }
      }

      function work() {
          var process;
          var steps = 0;

          while (steps < MAX_STEPS && (process = workQueue.shift())) {
              var msg;
              if ((msg = process.messageQueue.shift())) {
                  process.onMessage(msg);
              }
              steps = steps + 1;
          }

          if (!msg) {
              working = false;
              return;
          }
          setTimeout(work, 0);
      }

      return {
          spawn: spawn,
          send: send
      };
  })();

  exports.scheduler = scheduler;
})(PS["Dominator.Native.Scheduler"] = PS["Dominator.Native.Scheduler"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Dominator.Native.Scheduler"];
  exports["scheduler"] = $foreign.scheduler;
})(PS["Dominator.Native.Scheduler"] = PS["Dominator.Native.Scheduler"] || {});
(function(exports) {/* globals  
    _elm_lang$core$Native_Utils, 
    _elm_lang$core$Platform_Cmd$none,
    _elm_lang$core$Platform_Sub$none,
    _elm_lang$core$Native_Platform,
    _elm_lang$core$Native_Scheduler
*/  
  /* eslint-disable no-unused-vars, no-use-before-define, no-redeclare, complexity, max-len */
  // Compiler functions

  var _Native_Json = (function() {
      function run(decoder, value) {
          return decoder(value);
      }

      function map(tagger, decoder) {
          return function(v) {
              return tagger(decoder(v));
          };
      }

      function equality(a, b) {
          if (a === b) {
              return true;
          }

          if (a.tag !== b.tag) {
              return false;
          }

          switch (a.tag) {
              case "succeed":
              case "fail":
                  return a.msg === b.msg;

              case "bool":
              case "int":
              case "float":
              case "string":
              case "value":
                  return true;

              case "null":
                  return a.value === b.value;

              case "list":
              case "array":
              case "maybe":
              case "key-value":
                  return equality(a.decoder, b.decoder);

              case "field":
                  return a.field === b.field && equality(a.decoder, b.decoder);

              case "index":
                  return a.index === b.index && equality(a.decoder, b.decoder);

              case "map-many":
                  if (a.func !== b.func) {
                      return false;
                  }
                  return listEquality(a.decoders, b.decoders);

              case "andThen":
                  return a.callback === b.callback && equality(a.decoder, b.decoder);

              case "oneOf":
                  return listEquality(a.decoders, b.decoders);
          }
      }

      function listEquality(aDecoders, bDecoders) {
          var len = aDecoders.length;
          if (len !== bDecoders.length) {
              return false;
          }
          for (var i = 0; i < len; i++) {
              if (!equality(aDecoders[i], bDecoders[i])) {
                  return false;
              }
          }
          return true;
      }

      return {
          run: F2(run),
          equality: equality
      };
  })();

  function F(arity, fun, wrapper) {
      wrapper.a = arity;
      wrapper.f = fun;
      return wrapper;
  }

  function F2(fun) {
      return F(2, fun, function(a) {
          return function(b) {
              return fun(a, b);
          };
      });
  }
  function F3(fun) {
      return F(3, fun, function(a) {
          return function(b) {
              return function(c) {
                  return fun(a, b, c);
              };
          };
      });
  }
  function F4(fun) {
      return F(4, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return fun(a, b, c, d);
                  };
              };
          };
      });
  }
  function F5(fun) {
      return F(5, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return fun(a, b, c, d, e);
                      };
                  };
              };
          };
      });
  }
  function F6(fun) {
      return F(6, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return fun(a, b, c, d, e, f);
                          };
                      };
                  };
              };
          };
      });
  }
  function F7(fun) {
      return F(7, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return function(g) {
                                  return fun(a, b, c, d, e, f, g);
                              };
                          };
                      };
                  };
              };
          };
      });
  }
  function F8(fun) {
      return F(8, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return function(g) {
                                  return function(h) {
                                      return fun(a, b, c, d, e, f, g, h);
                                  };
                              };
                          };
                      };
                  };
              };
          };
      });
  }
  function F9(fun) {
      return F(9, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return function(g) {
                                  return function(h) {
                                      return function(i) {
                                          return fun(a, b, c, d, e, f, g, h, i);
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      });
  }

  function A2(fun, a, b) {
      return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
  }
  function A3(fun, a, b, c) {
      return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
  }
  function A4(fun, a, b, c, d) {
      return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
  }
  function A5(fun, a, b, c, d, e) {
      return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
  }
  function A6(fun, a, b, c, d, e, f) {
      return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
  }
  function A7(fun, a, b, c, d, e, f, g) {
      return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
  }
  function A8(fun, a, b, c, d, e, f, g, h) {
      return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
  }
  function A9(fun, a, b, c, d, e, f, g, h, i) {
      return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
  }

  // =============================================================
  // VIRTUAL DOM
  // =============================================================

  var _elm_lang$virtual_dom$VirtualDom_Debug$wrap;
  var _elm_lang$virtual_dom$VirtualDom_Debug$wrapWithFlags;

  var _elm_lang$virtual_dom$Native_VirtualDom = (function() {
      var STYLE_KEY = "STYLE";
      var EVENT_KEY = "EVENT";
      var ATTR_KEY = "ATTR";
      var ATTR_NS_KEY = "ATTR_NS";

      var localDoc = typeof document !== "undefined" ? document : {};

      ////////////  VIRTUAL DOM NODES  ////////////

      function text(string) {
          return {
              type: "text",
              text: string
          };
      }

      function node(tag) {
          return F2(function(factList, kidList) {
              return nodeHelp(tag, factList, kidList);
          });
      }

      function nodeHelp(tag, factList, kidList) {
          var organized = organizeFacts(factList);
          var namespace = organized.namespace;
          var facts = organized.facts;

          var children = [];
          var descendantsCount = 0;
          while (kidList.constructor.name !== "Nil") {
              var kid = kidList.value0;
              descendantsCount += kid.descendantsCount || 0;
              children.push(kid);
              kidList = kidList.value1;
          }
          descendantsCount += children.length;

          return {
              type: "node",
              tag: tag,
              facts: facts,
              children: children,
              namespace: namespace,
              descendantsCount: descendantsCount
          };
      }

      function keyedNode(tag, factList, kidList) {
          var organized = organizeFacts(factList);
          var namespace = organized.namespace;
          var facts = organized.facts;

          var children = [];
          var descendantsCount = 0;
          while (kidList.constructor.name !== "Nil") {
              var kid = kidList.value0;
              descendantsCount += kid.value1.descendantsCount || 0;
              children.push(kid);
              kidList = kidList.value1;
          }
          descendantsCount += children.length;

          return {
              type: "keyed-node",
              tag: tag,
              facts: facts,
              children: children,
              namespace: namespace,
              descendantsCount: descendantsCount
          };
      }

      function custom(factList, model, impl) {
          var facts = organizeFacts(factList).facts;

          return {
              type: "custom",
              facts: facts,
              model: model,
              impl: impl
          };
      }

      function map(tagger, node) {
          return {
              type: "tagger",
              tagger: tagger,
              node: node,
              descendantsCount: 1 + (node.descendantsCount || 0)
          };
      }

      function thunk(func, args, thunk) {
          return {
              type: "thunk",
              func: func,
              args: args,
              thunk: thunk,
              node: undefined
          };
      }

      function lazy(fn, a) {
          return thunk(fn, [a], function() {
              return fn(a);
          });
      }

      function lazy2(fn, a, b) {
          return thunk(fn, [a, b], function() {
              return A2(fn, a, b);
          });
      }

      function lazy3(fn, a, b, c) {
          return thunk(fn, [a, b, c], function() {
              return A3(fn, a, b, c);
          });
      }

      // FACTS

      function organizeFacts(factList) {
          var namespace,
              facts = {};

          while (factList.constructor.name !== "Nil") {
              var entry = factList.value0;
              var key = entry.key;

              if (key === ATTR_KEY || key === ATTR_NS_KEY || key === EVENT_KEY) {
                  var subFacts = facts[key] || {};
                  subFacts[entry.realKey] = entry.value;
                  facts[key] = subFacts;
              } else if (key === STYLE_KEY) {
                  var styles = facts[key] || {};
                  var styleList = entry.value;
                  while (styleList.constructor.name !== "Nil") {
                      var style = styleList.value0;
                      styles[style.value0] = style.value1;
                      styleList = styleList.value1;
                  }
                  facts[key] = styles;
              } else if (key === "namespace") {
                  namespace = entry.value;
              } else if (key === "className") {
                  var classes = facts[key];
                  facts[key] =
                      typeof classes === "undefined" ? entry.value : classes + " " + entry.value;
              } else {
                  facts[key] = entry.value;
              }
              factList = factList.value1;
          }

          return {
              facts: facts,
              namespace: namespace
          };
      }

      ////////////  PROPERTIES AND ATTRIBUTES  ////////////

      function style(value) {
          return {
              key: STYLE_KEY,
              value: value
          };
      }

      function property(key, value) {
          return {
              key: key,
              value: value
          };
      }

      function attribute(key, value) {
          return {
              key: ATTR_KEY,
              realKey: key,
              value: value
          };
      }

      function attributeNS(namespace, key, value) {
          return {
              key: ATTR_NS_KEY,
              realKey: key,
              value: {
                  value: value,
                  namespace: namespace
              }
          };
      }

      function on(name, options, decoder) {
          return {
              key: EVENT_KEY,
              realKey: name,
              value: {
                  options: options,
                  decoder: decoder
              }
          };
      }

      function equalEvents(a, b) {
          if (a.options !== b.options) {
              if (
                  a.options.stopPropagation !== b.options.stopPropagation ||
                  a.options.preventDefault !== b.options.preventDefault
              ) {
                  return false;
              }
          }
          return _Native_Json.equality(a.decoder, b.decoder);
      }

      function mapProperty(func, property) {
          if (property.key !== EVENT_KEY) {
              return property;
          }
          return on(
              property.realKey,
              property.value.options,
              A2(_Native_Json.map, func, property.value.decoder)
          );
      }

      ////////////  RENDER  ////////////

      function render(vNode, eventNode) {
          switch (vNode.type) {
              case "thunk":
                  if (!vNode.node) {
                      vNode.node = vNode.thunk();
                  }
                  return render(vNode.node, eventNode);

              case "tagger":
                  var subNode = vNode.node;
                  var tagger = vNode.tagger;

                  while (subNode.type === "tagger") {
                      typeof tagger !== "object"
                          ? (tagger = [tagger, subNode.tagger])
                          : tagger.push(subNode.tagger);

                      subNode = subNode.node;
                  }

                  var subEventRoot = { tagger: tagger, parent: eventNode };
                  var domNode = render(subNode, subEventRoot);
                  domNode.elm_event_node_ref = subEventRoot;
                  return domNode;

              case "text":
                  return localDoc.createTextNode(vNode.text);

              case "node":
                  var domNode = vNode.namespace
                      ? localDoc.createElementNS(vNode.namespace, vNode.tag)
                      : localDoc.createElement(vNode.tag);

                  applyFacts(domNode, eventNode, vNode.facts);

                  var children = vNode.children;

                  for (var i = 0; i < children.length; i++) {
                      domNode.appendChild(render(children[i], eventNode));
                  }

                  return domNode;

              case "keyed-node":
                  var domNode = vNode.namespace
                      ? localDoc.createElementNS(vNode.namespace, vNode.tag)
                      : localDoc.createElement(vNode.tag);

                  applyFacts(domNode, eventNode, vNode.facts);

                  var children = vNode.children;

                  for (var i = 0; i < children.length; i++) {
                      domNode.appendChild(render(children[i].value1, eventNode));
                  }

                  return domNode;

              case "custom":
                  var domNode = vNode.impl.render(vNode.model);
                  applyFacts(domNode, eventNode, vNode.facts);
                  return domNode;
          }
      }

      ////////////  APPLY FACTS  ////////////

      function applyFacts(domNode, eventNode, facts) {
          for (var key in facts) {
              var value = facts[key];

              switch (key) {
                  case STYLE_KEY:
                      applyStyles(domNode, value);
                      break;

                  case EVENT_KEY:
                      applyEvents(domNode, eventNode, value);
                      break;

                  case ATTR_KEY:
                      applyAttrs(domNode, value);
                      break;

                  case ATTR_NS_KEY:
                      applyAttrsNS(domNode, value);
                      break;

                  case "value":
                      if (domNode[key] !== value) {
                          domNode[key] = value;
                      }
                      break;

                  default:
                      domNode[key] = value;
                      break;
              }
          }
      }

      function applyStyles(domNode, styles) {
          var domNodeStyle = domNode.style;

          for (var key in styles) {
              domNodeStyle[key] = styles[key];
          }
      }

      function applyEvents(domNode, eventNode, events) {
          var allHandlers = domNode.elm_handlers || {};

          for (var key in events) {
              var handler = allHandlers[key];
              var value = events[key];

              if (typeof value === "undefined") {
                  domNode.removeEventListener(key, handler);
                  allHandlers[key] = undefined;
              } else if (typeof handler === "undefined") {
                  var handler = makeEventHandler(eventNode, value);
                  domNode.addEventListener(key, handler);
                  allHandlers[key] = handler;
              } else {
                  handler.info = value;
              }
          }

          domNode.elm_handlers = allHandlers;
      }

      function makeEventHandler(eventNode, info) {
          function eventHandler(event) {
              var info = eventHandler.info;

              var value = A2(_Native_Json.run, info.decoder, event);

              if (value.constructor.name === "Right") {
                  var options = info.options;
                  if (options.stopPropagation) {
                      event.stopPropagation();
                  }
                  if (options.preventDefault) {
                      event.preventDefault();
                  }

                  var message = value.value0;

                  var currentEventNode = eventNode;
                  while (currentEventNode) {
                      var tagger = currentEventNode.tagger;
                      if (typeof tagger === "function") {
                          message = tagger(message);
                      } else {
                          for (var i = tagger.length; i--; ) {
                              message = tagger[i](message);
                          }
                      }
                      currentEventNode = currentEventNode.parent;
                  }
              }
          }

          eventHandler.info = info;

          return eventHandler;
      }

      function applyAttrs(domNode, attrs) {
          for (var key in attrs) {
              var value = attrs[key];
              if (typeof value === "undefined") {
                  domNode.removeAttribute(key);
              } else {
                  domNode.setAttribute(key, value);
              }
          }
      }

      function applyAttrsNS(domNode, nsAttrs) {
          for (var key in nsAttrs) {
              var pair = nsAttrs[key];
              var namespace = pair.namespace;
              var value = pair.value;

              if (typeof value === "undefined") {
                  domNode.removeAttributeNS(namespace, key);
              } else {
                  domNode.setAttributeNS(namespace, key, value);
              }
          }
      }

      ////////////  DIFF  ////////////

      function diff(a, b) {
          var patches = [];
          diffHelp(a, b, patches, 0);
          return patches;
      }

      function makePatch(type, index, data) {
          return {
              index: index,
              type: type,
              data: data,
              domNode: undefined,
              eventNode: undefined
          };
      }

      function diffHelp(a, b, patches, index) {
          if (a === b) {
              return;
          }

          var aType = a.type;
          var bType = b.type;

          // Bail if you run into different types of nodes. Implies that the
          // structure has changed significantly and it's not worth a diff.
          if (aType !== bType) {
              patches.push(makePatch("p-redraw", index, b));
              return;
          }

          // Now we know that both nodes are the same type.
          switch (bType) {
              case "thunk":
                  var aArgs = a.args;
                  var bArgs = b.args;
                  var i = aArgs.length;
                  var same = a.func === b.func && i === bArgs.length;
                  while (same && i--) {
                      same = aArgs[i] === bArgs[i];
                  }
                  if (same) {
                      b.node = a.node;
                      return;
                  }
                  b.node = b.thunk();
                  var subPatches = [];
                  diffHelp(a.node, b.node, subPatches, 0);
                  if (subPatches.length > 0) {
                      patches.push(makePatch("p-thunk", index, subPatches));
                  }
                  return;

              case "tagger":
                  // gather nested taggers
                  var aTaggers = a.tagger;
                  var bTaggers = b.tagger;
                  var nesting = false;

                  var aSubNode = a.node;
                  while (aSubNode.type === "tagger") {
                      nesting = true;

                      typeof aTaggers !== "object"
                          ? (aTaggers = [aTaggers, aSubNode.tagger])
                          : aTaggers.push(aSubNode.tagger);

                      aSubNode = aSubNode.node;
                  }

                  var bSubNode = b.node;
                  while (bSubNode.type === "tagger") {
                      nesting = true;

                      typeof bTaggers !== "object"
                          ? (bTaggers = [bTaggers, bSubNode.tagger])
                          : bTaggers.push(bSubNode.tagger);

                      bSubNode = bSubNode.node;
                  }

                  // Just bail if different numbers of taggers. This implies the
                  // structure of the virtual DOM has changed.
                  if (nesting && aTaggers.length !== bTaggers.length) {
                      patches.push(makePatch("p-redraw", index, b));
                      return;
                  }

                  // check if taggers are "the same"
                  if (nesting ? !pairwiseRefEqual(aTaggers, bTaggers) : aTaggers !== bTaggers) {
                      patches.push(makePatch("p-tagger", index, bTaggers));
                  }

                  // diff everything below the taggers
                  diffHelp(aSubNode, bSubNode, patches, index + 1);
                  return;

              case "text":
                  if (a.text !== b.text) {
                      patches.push(makePatch("p-text", index, b.text));
                      return;
                  }

                  return;

              case "node":
                  // Bail if obvious indicators have changed. Implies more serious
                  // structural changes such that it's not worth it to diff.
                  if (a.tag !== b.tag || a.namespace !== b.namespace) {
                      patches.push(makePatch("p-redraw", index, b));
                      return;
                  }

                  var factsDiff = diffFacts(a.facts, b.facts);

                  if (typeof factsDiff !== "undefined") {
                      patches.push(makePatch("p-facts", index, factsDiff));
                  }

                  diffChildren(a, b, patches, index);
                  return;

              case "keyed-node":
                  // Bail if obvious indicators have changed. Implies more serious
                  // structural changes such that it's not worth it to diff.
                  if (a.tag !== b.tag || a.namespace !== b.namespace) {
                      patches.push(makePatch("p-redraw", index, b));
                      return;
                  }

                  var factsDiff = diffFacts(a.facts, b.facts);

                  if (typeof factsDiff !== "undefined") {
                      patches.push(makePatch("p-facts", index, factsDiff));
                  }

                  diffKeyedChildren(a, b, patches, index);
                  return;

              case "custom":
                  if (a.impl !== b.impl) {
                      patches.push(makePatch("p-redraw", index, b));
                      return;
                  }

                  var factsDiff = diffFacts(a.facts, b.facts);
                  if (typeof factsDiff !== "undefined") {
                      patches.push(makePatch("p-facts", index, factsDiff));
                  }

                  var patch = b.impl.diff(a, b);
                  if (patch) {
                      patches.push(makePatch("p-custom", index, patch));
                      return;
                  }

                  return;
          }
      }

      // assumes the incoming arrays are the same length
      function pairwiseRefEqual(as, bs) {
          for (var i = 0; i < as.length; i++) {
              if (as[i] !== bs[i]) {
                  return false;
              }
          }

          return true;
      }

      // TODO Instead of creating a new diff object, it's possible to just test if
      // there *is* a diff. During the actual patch, do the diff again and make the
      // modifications directly. This way, there's no new allocations. Worth it?
      function diffFacts(a, b, category) {
          var diff;

          // look for changes and removals
          for (var aKey in a) {
              if (
                  aKey === STYLE_KEY ||
                  aKey === EVENT_KEY ||
                  aKey === ATTR_KEY ||
                  aKey === ATTR_NS_KEY
              ) {
                  var subDiff = diffFacts(a[aKey], b[aKey] || {}, aKey);
                  if (subDiff) {
                      diff = diff || {};
                      diff[aKey] = subDiff;
                  }
                  continue;
              }

              // remove if not in the new facts
              if (!(aKey in b)) {
                  diff = diff || {};
                  diff[aKey] =
                      typeof category === "undefined"
                          ? typeof a[aKey] === "string" ? "" : null
                          : category === STYLE_KEY
                              ? ""
                              : category === EVENT_KEY || category === ATTR_KEY
                                  ? undefined
                                  : { namespace: a[aKey].namespace, value: undefined };

                  continue;
              }

              var aValue = a[aKey];
              var bValue = b[aKey];

              // reference equal, so don't worry about it
              if (
                  (aValue === bValue && aKey !== "value") ||
                  (category === EVENT_KEY && equalEvents(aValue, bValue))
              ) {
                  continue;
              }

              diff = diff || {};
              diff[aKey] = bValue;
          }

          // add new stuff
          for (var bKey in b) {
              if (!(bKey in a)) {
                  diff = diff || {};
                  diff[bKey] = b[bKey];
              }
          }

          return diff;
      }

      function diffChildren(aParent, bParent, patches, rootIndex) {
          var aChildren = aParent.children;
          var bChildren = bParent.children;

          var aLen = aChildren.length;
          var bLen = bChildren.length;

          // FIGURE OUT IF THERE ARE INSERTS OR REMOVALS

          if (aLen > bLen) {
              patches.push(makePatch("p-remove-last", rootIndex, aLen - bLen));
          } else if (aLen < bLen) {
              patches.push(makePatch("p-append", rootIndex, bChildren.slice(aLen)));
          }

          // PAIRWISE DIFF EVERYTHING ELSE

          var index = rootIndex;
          var minLen = aLen < bLen ? aLen : bLen;
          for (var i = 0; i < minLen; i++) {
              index++;
              var aChild = aChildren[i];
              diffHelp(aChild, bChildren[i], patches, index);
              index += aChild.descendantsCount || 0;
          }
      }

      ////////////  KEYED DIFF  ////////////

      function diffKeyedChildren(aParent, bParent, patches, rootIndex) {
          var localPatches = [];

          var changes = {}; // Dict String Entry
          var inserts = []; // Array { index : Int, entry : Entry }
          // type Entry = { tag : String, vnode : VNode, index : Int, data : _ }

          var aChildren = aParent.children;
          var bChildren = bParent.children;
          var aLen = aChildren.length;
          var bLen = bChildren.length;
          var aIndex = 0;
          var bIndex = 0;

          var index = rootIndex;

          while (aIndex < aLen && bIndex < bLen) {
              var a = aChildren[aIndex];
              var b = bChildren[bIndex];

              var aKey = a.value0;
              var bKey = b.value0;
              var aNode = a.value1;
              var bNode = b.value1;

              // check if keys match

              if (aKey === bKey) {
                  index++;
                  diffHelp(aNode, bNode, localPatches, index);
                  index += aNode.descendantsCount || 0;

                  aIndex++;
                  bIndex++;
                  continue;
              }

              // look ahead 1 to detect insertions and removals.

              var aLookAhead = aIndex + 1 < aLen;
              var bLookAhead = bIndex + 1 < bLen;

              if (aLookAhead) {
                  var aNext = aChildren[aIndex + 1];
                  var aNextKey = aNext.value0;
                  var aNextNode = aNext.value1;
                  var oldMatch = bKey === aNextKey;
              }

              if (bLookAhead) {
                  var bNext = bChildren[bIndex + 1];
                  var bNextKey = bNext.value0;
                  var bNextNode = bNext.value1;
                  var newMatch = aKey === bNextKey;
              }

              // swap a and b
              if (aLookAhead && bLookAhead && newMatch && oldMatch) {
                  index++;
                  diffHelp(aNode, bNextNode, localPatches, index);
                  insertNode(changes, localPatches, aKey, bNode, bIndex, inserts);
                  index += aNode.descendantsCount || 0;

                  index++;
                  removeNode(changes, localPatches, aKey, aNextNode, index);
                  index += aNextNode.descendantsCount || 0;

                  aIndex += 2;
                  bIndex += 2;
                  continue;
              }

              // insert b
              if (bLookAhead && newMatch) {
                  index++;
                  insertNode(changes, localPatches, bKey, bNode, bIndex, inserts);
                  diffHelp(aNode, bNextNode, localPatches, index);
                  index += aNode.descendantsCount || 0;

                  aIndex += 1;
                  bIndex += 2;
                  continue;
              }

              // remove a
              if (aLookAhead && oldMatch) {
                  index++;
                  removeNode(changes, localPatches, aKey, aNode, index);
                  index += aNode.descendantsCount || 0;

                  index++;
                  diffHelp(aNextNode, bNode, localPatches, index);
                  index += aNextNode.descendantsCount || 0;

                  aIndex += 2;
                  bIndex += 1;
                  continue;
              }

              // remove a, insert b
              if (aLookAhead && bLookAhead && aNextKey === bNextKey) {
                  index++;
                  removeNode(changes, localPatches, aKey, aNode, index);
                  insertNode(changes, localPatches, bKey, bNode, bIndex, inserts);
                  index += aNode.descendantsCount || 0;

                  index++;
                  diffHelp(aNextNode, bNextNode, localPatches, index);
                  index += aNextNode.descendantsCount || 0;

                  aIndex += 2;
                  bIndex += 2;
                  continue;
              }

              break;
          }

          // eat up any remaining nodes with removeNode and insertNode

          while (aIndex < aLen) {
              index++;
              var a = aChildren[aIndex];
              var aNode = a.value1;
              removeNode(changes, localPatches, a.value0, aNode, index);
              index += aNode.descendantsCount || 0;
              aIndex++;
          }

          var endInserts;
          while (bIndex < bLen) {
              endInserts = endInserts || [];
              var b = bChildren[bIndex];
              insertNode(changes, localPatches, b.value0, b.value1, undefined, endInserts);
              bIndex++;
          }

          if (localPatches.length > 0 || inserts.length > 0 || typeof endInserts !== "undefined") {
              patches.push(
                  makePatch("p-reorder", rootIndex, {
                      patches: localPatches,
                      inserts: inserts,
                      endInserts: endInserts
                  })
              );
          }
      }

      ////////////  CHANGES FROM KEYED DIFF  ////////////

      var POSTFIX = "_elmW6BL";

      function insertNode(changes, localPatches, key, vnode, bIndex, inserts) {
          var entry = changes[key];

          // never seen this key before
          if (typeof entry === "undefined") {
              entry = {
                  tag: "insert",
                  vnode: vnode,
                  index: bIndex,
                  data: undefined
              };

              inserts.push({ index: bIndex, entry: entry });
              changes[key] = entry;

              return;
          }

          // this key was removed earlier, a match!
          if (entry.tag === "remove") {
              inserts.push({ index: bIndex, entry: entry });

              entry.tag = "move";
              var subPatches = [];
              diffHelp(entry.vnode, vnode, subPatches, entry.index);
              entry.index = bIndex;
              entry.data.data = {
                  patches: subPatches,
                  entry: entry
              };

              return;
          }

          // this key has already been inserted or moved, a duplicate!
          insertNode(changes, localPatches, key + POSTFIX, vnode, bIndex, inserts);
      }

      function removeNode(changes, localPatches, key, vnode, index) {
          var entry = changes[key];

          // never seen this key before
          if (typeof entry === "undefined") {
              var patch = makePatch("p-remove", index, undefined);
              localPatches.push(patch);

              changes[key] = {
                  tag: "remove",
                  vnode: vnode,
                  index: index,
                  data: patch
              };

              return;
          }

          // this key was inserted earlier, a match!
          if (entry.tag === "insert") {
              entry.tag = "move";
              var subPatches = [];
              diffHelp(vnode, entry.vnode, subPatches, index);

              var patch = makePatch("p-remove", index, {
                  patches: subPatches,
                  entry: entry
              });
              localPatches.push(patch);

              return;
          }

          // this key has already been removed or moved, a duplicate!
          removeNode(changes, localPatches, key + POSTFIX, vnode, index);
      }

      ////////////  ADD DOM NODES  ////////////
      //
      // Each DOM node has an "index" assigned in order of traversal. It is important
      // to minimize our crawl over the actual DOM, so these indexes (along with the
      // descendantsCount of virtual nodes) let us skip touching entire subtrees of
      // the DOM if we know there are no patches there.

      function addDomNodes(domNode, vNode, patches, eventNode) {
          addDomNodesHelp(domNode, vNode, patches, 0, 0, vNode.descendantsCount, eventNode);
      }

      // assumes `patches` is non-empty and indexes increase monotonically.
      function addDomNodesHelp(domNode, vNode, patches, i, low, high, eventNode) {
          var patch = patches[i];
          var index = patch.index;

          while (index === low) {
              var patchType = patch.type;

              if (patchType === "p-thunk") {
                  addDomNodes(domNode, vNode.node, patch.data, eventNode);
              } else if (patchType === "p-reorder") {
                  patch.domNode = domNode;
                  patch.eventNode = eventNode;

                  var subPatches = patch.data.patches;
                  if (subPatches.length > 0) {
                      addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
                  }
              } else if (patchType === "p-remove") {
                  patch.domNode = domNode;
                  patch.eventNode = eventNode;

                  var data = patch.data;
                  if (typeof data !== "undefined") {
                      data.entry.data = domNode;
                      var subPatches = data.patches;
                      if (subPatches.length > 0) {
                          addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
                      }
                  }
              } else {
                  patch.domNode = domNode;
                  patch.eventNode = eventNode;
              }

              i++;

              if (!(patch = patches[i]) || (index = patch.index) > high) {
                  return i;
              }
          }

          switch (vNode.type) {
              case "tagger":
                  var subNode = vNode.node;

                  while (subNode.type === "tagger") {
                      subNode = subNode.node;
                  }

                  return addDomNodesHelp(
                      domNode,
                      subNode,
                      patches,
                      i,
                      low + 1,
                      high,
                      domNode.elm_event_node_ref
                  );

              case "node":
                  var vChildren = vNode.children;
                  var childNodes = domNode.childNodes;
                  for (var j = 0; j < vChildren.length; j++) {
                      low++;
                      var vChild = vChildren[j];
                      var nextLow = low + (vChild.descendantsCount || 0);
                      if (low <= index && index <= nextLow) {
                          i = addDomNodesHelp(
                              childNodes[j],
                              vChild,
                              patches,
                              i,
                              low,
                              nextLow,
                              eventNode
                          );
                          if (!(patch = patches[i]) || (index = patch.index) > high) {
                              return i;
                          }
                      }
                      low = nextLow;
                  }
                  return i;

              case "keyed-node":
                  var vChildren = vNode.children;
                  var childNodes = domNode.childNodes;
                  for (var j = 0; j < vChildren.length; j++) {
                      low++;
                      var vChild = vChildren[j].value1;
                      var nextLow = low + (vChild.descendantsCount || 0);
                      if (low <= index && index <= nextLow) {
                          i = addDomNodesHelp(
                              childNodes[j],
                              vChild,
                              patches,
                              i,
                              low,
                              nextLow,
                              eventNode
                          );
                          if (!(patch = patches[i]) || (index = patch.index) > high) {
                              return i;
                          }
                      }
                      low = nextLow;
                  }
                  return i;

              case "text":
              case "thunk":
                  throw new Error("should never traverse `text` or `thunk` nodes like this");
          }
      }

      ////////////  APPLY PATCHES  ////////////

      function applyPatches(rootDomNode, oldVirtualNode, patches, eventNode) {
          if (patches.length === 0) {
              return rootDomNode;
          }

          addDomNodes(rootDomNode, oldVirtualNode, patches, eventNode);
          return applyPatchesHelp(rootDomNode, patches);
      }

      function applyPatchesHelp(rootDomNode, patches) {
          for (var i = 0; i < patches.length; i++) {
              var patch = patches[i];
              var localDomNode = patch.domNode;
              var newNode = applyPatch(localDomNode, patch);
              if (localDomNode === rootDomNode) {
                  rootDomNode = newNode;
              }
          }
          return rootDomNode;
      }

      function applyPatch(domNode, patch) {
          switch (patch.type) {
              case "p-redraw":
                  return applyPatchRedraw(domNode, patch.data, patch.eventNode);

              case "p-facts":
                  applyFacts(domNode, patch.eventNode, patch.data);
                  return domNode;

              case "p-text":
                  domNode.replaceData(0, domNode.length, patch.data);
                  return domNode;

              case "p-thunk":
                  return applyPatchesHelp(domNode, patch.data);

              case "p-tagger":
                  if (typeof domNode.elm_event_node_ref !== "undefined") {
                      domNode.elm_event_node_ref.tagger = patch.data;
                  } else {
                      domNode.elm_event_node_ref = { tagger: patch.data, parent: patch.eventNode };
                  }
                  return domNode;

              case "p-remove-last":
                  var i = patch.data;
                  while (i--) {
                      domNode.removeChild(domNode.lastChild);
                  }
                  return domNode;

              case "p-append":
                  var newNodes = patch.data;
                  for (var i = 0; i < newNodes.length; i++) {
                      domNode.appendChild(render(newNodes[i], patch.eventNode));
                  }
                  return domNode;

              case "p-remove":
                  var data = patch.data;
                  if (typeof data === "undefined") {
                      domNode.parentNode.removeChild(domNode);
                      return domNode;
                  }
                  var entry = data.entry;
                  if (typeof entry.index !== "undefined") {
                      domNode.parentNode.removeChild(domNode);
                  }
                  entry.data = applyPatchesHelp(domNode, data.patches);
                  return domNode;

              case "p-reorder":
                  return applyPatchReorder(domNode, patch);

              case "p-custom":
                  var impl = patch.data;
                  return impl.applyPatch(domNode, impl.data);

              default:
                  throw new Error("Ran into an unknown patch!");
          }
      }

      function applyPatchRedraw(domNode, vNode, eventNode) {
          var parentNode = domNode.parentNode;
          var newNode = render(vNode, eventNode);

          if (typeof newNode.elm_event_node_ref === "undefined") {
              newNode.elm_event_node_ref = domNode.elm_event_node_ref;
          }

          if (parentNode && newNode !== domNode) {
              parentNode.replaceChild(newNode, domNode);
          }
          return newNode;
      }

      function applyPatchReorder(domNode, patch) {
          var data = patch.data;

          // remove end inserts
          var frag = applyPatchReorderEndInsertsHelp(data.endInserts, patch);

          // removals
          domNode = applyPatchesHelp(domNode, data.patches);

          // inserts
          var inserts = data.inserts;
          for (var i = 0; i < inserts.length; i++) {
              var insert = inserts[i];
              var entry = insert.entry;
              var node = entry.tag === "move" ? entry.data : render(entry.vnode, patch.eventNode);
              domNode.insertBefore(node, domNode.childNodes[insert.index]);
          }

          // add end inserts
          if (typeof frag !== "undefined") {
              domNode.appendChild(frag);
          }

          return domNode;
      }

      function applyPatchReorderEndInsertsHelp(endInserts, patch) {
          if (typeof endInserts === "undefined") {
              return;
          }

          var frag = localDoc.createDocumentFragment();
          for (var i = 0; i < endInserts.length; i++) {
              var insert = endInserts[i];
              var entry = insert.entry;
              frag.appendChild(
                  entry.tag === "move" ? entry.data : render(entry.vnode, patch.eventNode)
              );
          }
          return frag;
      }

      // PROGRAMS

      var program = makeProgram(checkNoFlags);
      var programWithFlags = makeProgram(checkYesFlags);

      function makeProgram(flagChecker) {
          return F2(function(debugWrap, impl) {
              return function(flagDecoder) {
                  return function(object, moduleName, debugMetadata) {
                      var checker = flagChecker(flagDecoder, moduleName);
                      if (typeof debugMetadata === "undefined") {
                          normalSetup(impl, object, moduleName, checker);
                      } else {
                          debugSetup(A2(debugWrap, debugMetadata, impl), object, moduleName, checker);
                      }
                  };
              };
          });
      }

      function staticProgram(vNode) {
          var nothing = _elm_lang$core$Native_Utils.Tuple2(
              _elm_lang$core$Native_Utils.Tuple0,
              _elm_lang$core$Platform_Cmd$none
          );
          return A2(program, _elm_lang$virtual_dom$VirtualDom_Debug$wrap, {
              init: nothing,
              view: function() {
                  return vNode;
              },
              update: F2(function() {
                  return nothing;
              }),
              subscriptions: function() {
                  return _elm_lang$core$Platform_Sub$none;
              }
          })();
      }

      // FLAG CHECKERS

      function checkNoFlags(flagDecoder, moduleName) {
          return function(init, flags, domNode) {
              if (typeof flags === "undefined") {
                  return init;
              }

              var errorMessage =
                  "The `" +
                  moduleName +
                  "` module does not need flags.\n" +
                  "Initialize it with no arguments and you should be all set!";

              crash(errorMessage, domNode);
          };
      }

      function checkYesFlags(flagDecoder, moduleName) {
          return function(init, flags, domNode) {
              if (typeof flagDecoder === "undefined") {
                  var errorMessage =
                      "Are you trying to sneak a Never value into Dominator? Trickster!\n" +
                      "It looks like " +
                      moduleName +
                      ".main is defined with `programWithFlags` but has type `Program Never`.\n" +
                      "Use `program` instead if you do not want flags.";

                  crash(errorMessage, domNode);
              }

              var result = A2(_Native_Json.run, flagDecoder, flags);
              if (result.ctor === "Ok") {
                  return init(result.value0);
              }

              var errorMessage =
                  "Trying to initialize the `" +
                  moduleName +
                  "` module with an unexpected flag.\n" +
                  "I tried to convert it to an Dominator value, but ran into this problem:\n\n" +
                  result.value0;

              crash(errorMessage, domNode);
          };
      }

      function crash(errorMessage, domNode) {
          if (domNode) {
              domNode.innerHTML =
                  '<div style="padding-left:1em;">' +
                  '<h2 style="font-weight:normal;"><b>Oops!</b> Something went wrong when starting your Dominator program.</h2>' +
                  '<pre style="padding-left:1em;">' +
                  errorMessage +
                  "</pre>" +
                  "</div>";
          }

          throw new Error(errorMessage);
      }

      //  NORMAL SETUP

      function normalSetup(impl, object, moduleName, flagChecker) {
          object["embed"] = function embed(node, flags) {
              while (node.lastChild) {
                  node.removeChild(node.lastChild);
              }

              return _elm_lang$core$Native_Platform.initialize(
                  flagChecker(impl.init, flags, node),
                  impl.update,
                  impl.subscriptions,
                  normalRenderer(node, impl.view)
              );
          };

          object["fullscreen"] = function fullscreen(flags) {
              return _elm_lang$core$Native_Platform.initialize(
                  flagChecker(impl.init, flags, document.body),
                  impl.update,
                  impl.subscriptions,
                  normalRenderer(document.body, impl.view)
              );
          };
      }

      function normalRenderer(parentNode, view) {
          return function(tagger, initialModel) {
              var eventNode = { tagger: tagger, parent: undefined };
              var initialVirtualNode = view(initialModel);
              var domNode = render(initialVirtualNode, eventNode);
              parentNode.appendChild(domNode);
              return makeStepper(domNode, view, initialVirtualNode, eventNode);
          };
      }

      // STEPPER

      var rAF =
          typeof requestAnimationFrame !== "undefined"
              ? requestAnimationFrame
              : function(callback) {
                    setTimeout(callback, 1000 / 60);
                };

      function makeStepper(domNode, view, initialVirtualNode, eventNode) {
          var state = "NO_REQUEST";
          var currNode = initialVirtualNode;
          var nextModel;

          function updateIfNeeded() {
              switch (state) {
                  case "NO_REQUEST":
                      throw new Error(
                          "Unexpected draw callback.\n" +
                              "Please report this to <https://github.com/elm-lang/virtual-dom/issues>.")
                       ;

                  case "PENDING_REQUEST":
                      rAF(updateIfNeeded);
                      state = "EXTRA_REQUEST";

                      var nextNode = view(nextModel);
                      var patches = diff(currNode, nextNode);
                      domNode = applyPatches(domNode, currNode, patches, eventNode);
                      currNode = nextNode;

                      return;

                  case "EXTRA_REQUEST":
                      state = "NO_REQUEST";
                      return;
              }
          }

          return function stepper(model) {
              if (state === "NO_REQUEST") {
                  rAF(updateIfNeeded);
              }
              state = "PENDING_REQUEST";
              nextModel = model;
          };
      }

      // DEBUG SETUP

      function debugSetup(impl, object, moduleName, flagChecker) {
          object["fullscreen"] = function fullscreen(flags) {
              var popoutRef = { doc: undefined };
              return _elm_lang$core$Native_Platform.initialize(
                  flagChecker(impl.init, flags, document.body),
                  impl.update(scrollTask(popoutRef)),
                  impl.subscriptions,
                  debugRenderer(
                      moduleName,
                      document.body,
                      popoutRef,
                      impl.view,
                      impl.viewIn,
                      impl.viewOut
                  )
              );
          };

          object["embed"] = function fullscreen(node, flags) {
              var popoutRef = { doc: undefined };
              return _elm_lang$core$Native_Platform.initialize(
                  flagChecker(impl.init, flags, node),
                  impl.update(scrollTask(popoutRef)),
                  impl.subscriptions,
                  debugRenderer(moduleName, node, popoutRef, impl.view, impl.viewIn, impl.viewOut)
              );
          };
      }

      function scrollTask(popoutRef) {
          return _elm_lang$core$Native_Scheduler.nativeBinding(function(callback) {
              var doc = popoutRef.doc;
              if (doc) {
                  var msgs = doc.getElementsByClassName("debugger-sidebar-messages")[0];
                  if (msgs) {
                      msgs.scrollTop = msgs.scrollHeight;
                  }
              }
              callback(_elm_lang$core$Native_Scheduler.succeed(_elm_lang$core$Native_Utils.Tuple0));
          });
      }

      function debugRenderer(moduleName, parentNode, popoutRef, view, viewIn, viewOut) {
          return function(tagger, initialModel) {
              var appEventNode = { tagger: tagger, parent: undefined };
              var eventNode = { tagger: tagger, parent: undefined };

              // make normal stepper
              var appVirtualNode = view(initialModel);
              var appNode = render(appVirtualNode, appEventNode);
              parentNode.appendChild(appNode);
              var appStepper = makeStepper(appNode, view, appVirtualNode, appEventNode);

              // make overlay stepper
              var overVirtualNode = viewIn(initialModel).value1;
              var overNode = render(overVirtualNode, eventNode);
              parentNode.appendChild(overNode);
              var wrappedViewIn = wrapViewIn(appEventNode, overNode, viewIn);
              var overStepper = makeStepper(overNode, wrappedViewIn, overVirtualNode, eventNode);

              // make debugger stepper
              var debugStepper = makeDebugStepper(
                  initialModel,
                  viewOut,
                  eventNode,
                  parentNode,
                  moduleName,
                  popoutRef
              );

              return function stepper(model) {
                  appStepper(model);
                  overStepper(model);
                  debugStepper(model);
              };
          };
      }

      function makeDebugStepper(initialModel, view, eventNode, parentNode, moduleName, popoutRef) {
          var curr;
          var domNode;

          return function stepper(model) {
              if (!model.isDebuggerOpen) {
                  return;
              }

              if (!popoutRef.doc) {
                  curr = view(model);
                  domNode = openDebugWindow(moduleName, popoutRef, curr, eventNode);
                  return;
              }

              // switch to document of popout
              localDoc = popoutRef.doc;

              var next = view(model);
              var patches = diff(curr, next);
              domNode = applyPatches(domNode, curr, patches, eventNode);
              curr = next;

              // switch back to normal document
              localDoc = document;
          };
      }

      function openDebugWindow(moduleName, popoutRef, virtualNode, eventNode) {
          var w = 900;
          var h = 360;
          var x = screen.width - w;
          var y = screen.height - h;
          var debugWindow = window.open(
              "",
              "",
              "width=" + w + ",height=" + h + ",left=" + x + ",top=" + y
          );

          // switch to window document
          localDoc = debugWindow.document;

          popoutRef.doc = localDoc;
          localDoc.title = "Debugger - " + moduleName;
          localDoc.body.style.margin = "0";
          localDoc.body.style.padding = "0";
          var domNode = render(virtualNode, eventNode);
          localDoc.body.appendChild(domNode);

          localDoc.addEventListener("keydown", function(event) {
              if (event.metaKey && event.which === 82) {
                  window.location.reload();
              }
              if (event.which === 38) {
                  eventNode.tagger({ ctor: "Up" });
                  event.preventDefault();
              }
              if (event.which === 40) {
                  eventNode.tagger({ ctor: "Down" });
                  event.preventDefault();
              }
          });

          function close() {
              popoutRef.doc = undefined;
              debugWindow.close();
          }
          window.addEventListener("unload", close);
          debugWindow.addEventListener("unload", function() {
              popoutRef.doc = undefined;
              window.removeEventListener("unload", close);
              eventNode.tagger({ ctor: "Close" });
          });

          // switch back to the normal document
          localDoc = document;

          return domNode;
      }

      // BLOCK EVENTS

      function wrapViewIn(appEventNode, overlayNode, viewIn) {
          var ignorer = makeIgnorer(overlayNode);
          var blocking = "Normal";
          var overflow;

          var normalTagger = appEventNode.tagger;
          var blockTagger = function() {};

          return function(model) {
              var tuple = viewIn(model);
              var newBlocking = tuple.value0.ctor;
              appEventNode.tagger = newBlocking === "Normal" ? normalTagger : blockTagger;
              if (blocking !== newBlocking) {
                  traverse("removeEventListener", ignorer, blocking);
                  traverse("addEventListener", ignorer, newBlocking);

                  if (blocking === "Normal") {
                      overflow = document.body.style.overflow;
                      document.body.style.overflow = "hidden";
                  }

                  if (newBlocking === "Normal") {
                      document.body.style.overflow = overflow;
                  }

                  blocking = newBlocking;
              }
              return tuple.value1;
          };
      }

      function traverse(verbEventListener, ignorer, blocking) {
          switch (blocking) {
              case "Normal":
                  return;

              case "Pause":
                  return traverseHelp(verbEventListener, ignorer, mostEvents);

              case "Message":
                  return traverseHelp(verbEventListener, ignorer, allEvents);
          }
      }

      function traverseHelp(verbEventListener, handler, eventNames) {
          for (var i = 0; i < eventNames.length; i++) {
              document.body[verbEventListener](eventNames[i], handler, true);
          }
      }

      function makeIgnorer(overlayNode) {
          return function(event) {
              if (event.type === "keydown" && event.metaKey && event.which === 82) {
                  return;
              }

              var isScroll = event.type === "scroll" || event.type === "wheel";

              var node = event.target;
              while (node !== null) {
                  if (node.className === "elm-overlay-message-details" && isScroll) {
                      return;
                  }

                  if (node === overlayNode && !isScroll) {
                      return;
                  }
                  node = node.parentNode;
              }

              event.stopPropagation();
              event.preventDefault();
          };
      }

      var mostEvents = [
          "click",
          "dblclick",
          "mousemove",
          "mouseup",
          "mousedown",
          "mouseenter",
          "mouseleave",
          "touchstart",
          "touchend",
          "touchcancel",
          "touchmove",
          "pointerdown",
          "pointerup",
          "pointerover",
          "pointerout",
          "pointerenter",
          "pointerleave",
          "pointermove",
          "pointercancel",
          "dragstart",
          "drag",
          "dragend",
          "dragenter",
          "dragover",
          "dragleave",
          "drop",
          "keyup",
          "keydown",
          "keypress",
          "input",
          "change",
          "focus",
          "blur"
      ];

      var allEvents = mostEvents.concat("wheel", "scroll");

      return {
          node: node,
          text: text,
          custom: custom,
          map: F2(map),

          onWithOptions: F3(on),
          style: style,
          property: F2(property),
          attribute: F2(attribute),
          attributeNS: F3(attributeNS),
          mapProperty: F2(mapProperty),

          lazy: F2(lazy),
          lazy2: F3(lazy2),
          lazy3: F4(lazy3),
          keyedNode: F3(keyedNode),

          program: program,
          programWithFlags: programWithFlags,
          staticProgram: staticProgram,

          // Extra exposition
          normalRenderer: normalRenderer
      };
  })();

  var vdom = _elm_lang$virtual_dom$Native_VirtualDom;

  exports.node_ = vdom.node;
  exports.text = vdom.text;  

  exports.onWithOptions_ = vdom.onWithOptions;
  exports.style = vdom.style;
  exports.property = vdom.property;
  exports.attribute = vdom.attribute;
  exports.attributeNS = vdom.attributeNS;
  exports.mapProperty = vdom.mapProperty;

  exports.lazy = vdom.lazy;
  exports.lazy2 = vdom.lazy2;
  exports.lazy3 = vdom.lazy3;
  exports.keyedNode_ = vdom.keyedNode;

  // exports.program = vdom.program;
  // exports.programWithFlags = vdom.programWithFlags;
  // exports.staticProgram = vdom.staticProgram;
  exports.normalRenderer = vdom.normalRenderer;
})(PS["Dominator.Native.VirtualDom"] = PS["Dominator.Native.VirtualDom"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Dominator.Native.VirtualDom"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Data_Either = PS["Data.Either"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_List = PS["Data.List"];
  var Data_Tuple = PS["Data.Tuple"];
  var Dominator_Decode = PS["Dominator.Decode"];
  var Prelude = PS["Prelude"];
  var runDecoder = function (dec) {
      return function (val) {
          return Control_Monad_Except.runExcept(dec(val));
      };
  };
  var onWithOptions = function (s) {
      return function (o) {
          return function (d) {
              return $foreign.onWithOptions_(s)(o)(runDecoder(d));
          };
      };
  };
  var node = function (s) {
      return function (p) {
          return function (c) {
              return $foreign.node_(s)(Data_List.fromFoldable(Data_Foldable.foldableArray)(p))(Data_List.fromFoldable(Data_Foldable.foldableArray)(c));
          };
      };
  };
  var keyedNode = function (s) {
      return function (p) {
          return function (n) {
              return $foreign.keyedNode_(s)(Data_List.fromFoldable(Data_Foldable.foldableArray)(p))(Data_List.fromFoldable(Data_Foldable.foldableArray)(n));
          };
      };
  };                                                           
  var defaultOptions = {
      stopPropagation: false,
      preventDefault: false
  };
  var on = function (eventName) {
      return function (decoder) {
          return onWithOptions(eventName)(defaultOptions)(decoder);
      };
  };
  exports["node"] = node;
  exports["on"] = on;
  exports["onWithOptions"] = onWithOptions;
  exports["defaultOptions"] = defaultOptions;
  exports["keyedNode"] = keyedNode;
  exports["normalRenderer"] = $foreign.normalRenderer;
  exports["text"] = $foreign.text;
  exports["property"] = $foreign.property;
  exports["style"] = $foreign.style;
  exports["lazy"] = $foreign.lazy;
  exports["lazy2"] = $foreign.lazy2;
})(PS["Dominator.Native.VirtualDom"] = PS["Dominator.Native.VirtualDom"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Dominator.Native.Platform"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Tuple = PS["Data.Tuple"];
  var Dominator_Cmd = PS["Dominator.Cmd"];
  var Dominator_Native_Scheduler = PS["Dominator.Native.Scheduler"];
  var Dominator_Native_VirtualDom = PS["Dominator.Native.VirtualDom"];
  var Prelude = PS["Prelude"];
  exports["program"] = $foreign.program;
})(PS["Dominator.Native.Platform"] = PS["Dominator.Native.Platform"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Tuple = PS["Data.Tuple"];
  var Dominator_Cmd = PS["Dominator.Cmd"];
  var Dominator_Native_Platform = PS["Dominator.Native.Platform"];
  var Dominator_Native_Scheduler = PS["Dominator.Native.Scheduler"];
  var Dominator_Native_VirtualDom = PS["Dominator.Native.VirtualDom"];
  var Dominator_Operators = PS["Dominator.Operators"];
  var Prelude = PS["Prelude"];        
  var text = Dominator_Native_VirtualDom.text;
  var program = function (mayEl) {
      return function (v) {
          return Dominator_Native_Platform.program(mayEl)(Dominator_Native_Scheduler.scheduler)(Dominator_Native_VirtualDom.normalRenderer)(v.init)(v.update)(v.view);
      };
  };
  var node = Dominator_Native_VirtualDom.node;
  var p = node("p");      
  var section = node("section");
  var span = node("span");
  var strong = node("strong");
  var ul = node("ul");     
  var li = node("li");        
  var label = node("label");
  var input = node("input");
  var header = node("header");
  var h1 = node("h1");    
  var footer = node("footer");
  var div = node("div");      
  var button = node("button");
  var a = node("a");
  exports["text"] = text;
  exports["node"] = node;
  exports["program"] = program;
  exports["h1"] = h1;
  exports["div"] = div;
  exports["p"] = p;
  exports["span"] = span;
  exports["a"] = a;
  exports["strong"] = strong;
  exports["ul"] = ul;
  exports["li"] = li;
  exports["input"] = input;
  exports["button"] = button;
  exports["section"] = section;
  exports["header"] = header;
  exports["footer"] = footer;
  exports["label"] = label;
})(PS["Dominator.Html"] = PS["Dominator.Html"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Data_Array = PS["Data.Array"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Function = PS["Data.Function"];
  var Data_Function_Pipe = PS["Data.Function.Pipe"];
  var Data_Functor = PS["Data.Functor"];
  var Data_List = PS["Data.List"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Show = PS["Data.Show"];
  var Data_Tuple = PS["Data.Tuple"];
  var Dominator_Html = PS["Dominator.Html"];
  var Dominator_Native_VirtualDom = PS["Dominator.Native.VirtualDom"];
  var Prelude = PS["Prelude"];        
  var style = function (l) {
      return Dominator_Native_VirtualDom.style(Data_List.fromFoldable(Data_Foldable.foldableArray)(l));
  };
  var property = Dominator_Native_VirtualDom.property;
  var stringProperty = function (name_) {
      return function (string) {
          return property(name_)(Data_Foreign.toForeign(string));
      };
  };
  var type_ = function (v) {
      return stringProperty("type")(v);
  };
  var value = function (v) {
      return stringProperty("value")(v);
  };
  var placeholder = function (v) {
      return stringProperty("placeholder")(v);
  };
  var name = function (v) {
      return stringProperty("name")(v);
  };
  var id = function (name_) {
      return stringProperty("id")(name_);
  };
  var href = function (v) {
      return stringProperty("href")(v);
  };                                                
  var $$for = function (v) {
      return stringProperty("htmlFor")(v);
  };
  var class_ = function (name_) {
      return stringProperty("className")(name_);
  };
  var classList = function (list1) {
      return class_(Data_Foldable.intercalate(Data_Foldable.foldableArray)(Data_Monoid.monoidString)(" ")(Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.fst)(Data_Array.filter(Data_Tuple.snd)(list1))));
  };
  var boolProperty = function (name_) {
      return function (bool) {
          return property(name_)(Data_Foreign.toForeign(bool));
      };
  };
  var checked = function (bool) {
      return boolProperty("checked")(bool);
  };
  var hidden = function (bool) {
      return boolProperty("hidden")(bool);
  };
  var autofocus = function (bool) {
      return boolProperty("autofocus")(bool);
  };
  exports["style"] = style;
  exports["property"] = property;
  exports["class_"] = class_;
  exports["classList"] = classList;
  exports["id"] = id;
  exports["hidden"] = hidden;
  exports["type_"] = type_;
  exports["value"] = value;
  exports["checked"] = checked;
  exports["placeholder"] = placeholder;
  exports["autofocus"] = autofocus;
  exports["name"] = name;
  exports["for"] = $$for;
  exports["href"] = href;
})(PS["Dominator.Html.Attributes"] = PS["Dominator.Html.Attributes"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Foreign_Class = PS["Data.Foreign.Class"];
  var Data_Foreign_Index = PS["Data.Foreign.Index"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Identity = PS["Data.Identity"];
  var Dominator_Decode = PS["Dominator.Decode"];
  var Dominator_Html = PS["Dominator.Html"];
  var Dominator_Native_VirtualDom = PS["Dominator.Native.VirtualDom"];
  var Prelude = PS["Prelude"];        
  var targetValue = function (f) {
      return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity))(Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity))(Data_Foreign_Index.readProp("target")(f))(Data_Foreign_Index.readProp("value")))(Data_Foreign.readString);
  };
  var on = Dominator_Native_VirtualDom.on;
  var onBlur = function (msg) {
      return on("blur")(Data_Function["const"](Dominator_Decode.succeed(msg)));
  };
  var onClick = function (msg) {
      return on("click")(Data_Function["const"](Dominator_Decode.succeed(msg)));
  };
  var onDoubleClick = function (msg) {
      return on("dblclick")(Data_Function["const"](Dominator_Decode.succeed(msg)));
  };
  var onInput = function (tagger) {
      return on("input")(function ($4) {
          return Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(tagger)(targetValue($4));
      });
  };
  var keyCode = function (f) {
      return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity))(Data_Foreign_Index.readProp("keyCode")(f))(Data_Foreign.readInt);
  };
  exports["onClick"] = onClick;
  exports["onDoubleClick"] = onDoubleClick;
  exports["onInput"] = onInput;
  exports["onBlur"] = onBlur;
  exports["on"] = on;
  exports["targetValue"] = targetValue;
  exports["keyCode"] = keyCode;
})(PS["Dominator.Html.Events"] = PS["Dominator.Html.Events"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Data_Tuple = PS["Data.Tuple"];
  var Dominator_Html = PS["Dominator.Html"];
  var Dominator_Native_VirtualDom = PS["Dominator.Native.VirtualDom"];        
  var node = Dominator_Native_VirtualDom.keyedNode;
  var ul = node("ul");
  exports["node"] = node;
  exports["ul"] = ul;
})(PS["Dominator.Html.Keyed"] = PS["Dominator.Html.Keyed"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Dominator_Html = PS["Dominator.Html"];
  var Dominator_Native_VirtualDom = PS["Dominator.Native.VirtualDom"];
  var lazy2 = Dominator_Native_VirtualDom.lazy2;
  var lazy = Dominator_Native_VirtualDom.lazy;
  exports["lazy"] = lazy;
  exports["lazy2"] = lazy2;
})(PS["Dominator.Html.Lazy"] = PS["Dominator.Html.Lazy"] || {});
(function(exports) {exports.setStorage = function(state) {
      return function() {
          localStorage.setItem("dominator-todo-save", JSON.stringify(state));
      };
  };

  exports.focusElement = function(id) {
      return function() {
          var el = document.getElementById(id);
          if (el) {
              el.focus();
          }
      };
  };
})(PS["Todo"] = PS["Todo"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Todo"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad_Cont_Trans = PS["Control.Monad.Cont.Trans"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Array = PS["Data.Array"];
  var Data_Array_ST = PS["Data.Array.ST"];
  var Data_Either = PS["Data.Either"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Foreign_Class = PS["Data.Foreign.Class"];
  var Data_Foreign_Generic = PS["Data.Foreign.Generic"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Generic = PS["Data.Generic"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Identity = PS["Data.Identity"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_String = PS["Data.String"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unit = PS["Data.Unit"];
  var Dominator_Cmd = PS["Dominator.Cmd"];
  var Dominator_Decode = PS["Dominator.Decode"];
  var Dominator_Html = PS["Dominator.Html"];
  var Dominator_Html_Attributes = PS["Dominator.Html.Attributes"];
  var Dominator_Html_Events = PS["Dominator.Html.Events"];
  var Dominator_Html_Keyed = PS["Dominator.Html.Keyed"];
  var Dominator_Html_Lazy = PS["Dominator.Html.Lazy"];
  var Dominator_Operators = PS["Dominator.Operators"];
  var Prelude = PS["Prelude"];        

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var NoOp = (function () {
      function NoOp() {

      };
      NoOp.value = new NoOp();
      return NoOp;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var UpdateField = (function () {
      function UpdateField(value0) {
          this.value0 = value0;
      };
      UpdateField.create = function (value0) {
          return new UpdateField(value0);
      };
      return UpdateField;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var EditingEntry = (function () {
      function EditingEntry(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      EditingEntry.create = function (value0) {
          return function (value1) {
              return new EditingEntry(value0, value1);
          };
      };
      return EditingEntry;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var UpdateEntry = (function () {
      function UpdateEntry(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      UpdateEntry.create = function (value0) {
          return function (value1) {
              return new UpdateEntry(value0, value1);
          };
      };
      return UpdateEntry;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var Add = (function () {
      function Add() {

      };
      Add.value = new Add();
      return Add;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var Delete = (function () {
      function Delete(value0) {
          this.value0 = value0;
      };
      Delete.create = function (value0) {
          return new Delete(value0);
      };
      return Delete;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var DeleteComplete = (function () {
      function DeleteComplete() {

      };
      DeleteComplete.value = new DeleteComplete();
      return DeleteComplete;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var Check = (function () {
      function Check(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Check.create = function (value0) {
          return function (value1) {
              return new Check(value0, value1);
          };
      };
      return Check;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var CheckAll = (function () {
      function CheckAll(value0) {
          this.value0 = value0;
      };
      CheckAll.create = function (value0) {
          return new CheckAll(value0);
      };
      return CheckAll;
  })();

  // UPDATE
  /**
 * | Users of our app can trigger messages by clicking and typing. These
 * messages are fed into the `update` function as they occur, letting us react
 * to them.
 */  
  var ChangeVisibility = (function () {
      function ChangeVisibility(value0) {
          this.value0 = value0;
      };
      ChangeVisibility.create = function (value0) {
          return new ChangeVisibility(value0);
      };
      return ChangeVisibility;
  })();
  var Entry = function (x) {
      return x;
  };

  // MODEL
  // The full application state of our todo app.
  var Model = function (x) {
      return x;
  };
  var visibilitySwap = function (uri) {
      return function (visibility) {
          return function (actualVisibility) {
              return Dominator_Html.li([ Dominator_Html_Events.onClick(new ChangeVisibility(visibility)) ])([ Dominator_Html.a([ Dominator_Html_Attributes.href(uri), Dominator_Html_Attributes.classList([ new Data_Tuple.Tuple("selected", visibility === actualVisibility) ]) ])([ Dominator_Html.text(visibility) ]) ]);
          };
      };
  };
  var viewControlsFilters = function (visibility) {
      return Dominator_Html.ul([ Dominator_Html_Attributes.class_("filters") ])([ visibilitySwap("#/")("All")(visibility), Dominator_Html.text(" "), visibilitySwap("#/active")("Active")(visibility), Dominator_Html.text(" "), visibilitySwap("#/completed")("Completed")(visibility) ]);
  };
  var viewControlsCount = function (entriesLeft) {
      var item_ = (function () {
          var $32 = entriesLeft === 1;
          if ($32) {
              return " item";
          };
          return " items";
      })();
      return Dominator_Html.span([ Dominator_Html_Attributes.class_("todo-count") ])([ Dominator_Html.strong([  ])([ Dominator_Html.text(Data_Show.show(Data_Show.showInt)(entriesLeft)) ]), Dominator_Html.text(item_ + " left") ]);
  };
  var viewControlsClear = function (entriesCompleted) {
      return Dominator_Html.button([ Dominator_Html_Attributes.class_("clear-completed"), Dominator_Html_Attributes.hidden(entriesCompleted === 0), Dominator_Html_Events.onClick(DeleteComplete.value) ])([ Dominator_Html.text("Clear completed (" + (Data_Show.show(Data_Show.showInt)(entriesCompleted) + ")")) ]);
  };
  var parseFlags = function (v) {
      var parsed = Control_Monad_Except.runExcept(Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Foreign.unsafeFromForeign))(Data_Foreign.readNullOrUndefined(v)));
      if (parsed instanceof Data_Either.Right) {
          return parsed.value0;
      };
      if (parsed instanceof Data_Either.Left) {
          return Data_Maybe.Nothing.value;
      };
      throw new Error("Failed pattern match at Todo line 122, column 9 - line 124, column 30: " + [ parsed.constructor.name ]);
  };
  var onEnter = function (msg) {
      var isEnter = function (code) {
          var $36 = code === 13;
          if ($36) {
              return Dominator_Decode.succeed(msg);
          };
          return Dominator_Decode.fail("not ENTER");
      };
      return Dominator_Html_Events.on("keydown")(function (v) {
          return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity))(Dominator_Html_Events.keyCode(v))(isEnter);
      });
  };
  var viewEntry = function (v) {
      return Dominator_Html.li([ Dominator_Html_Attributes.classList([ new Data_Tuple.Tuple("completed", v.completed), new Data_Tuple.Tuple("editing", v.editing) ]) ])([ Dominator_Html.div([ Dominator_Html_Attributes.class_("view") ])([ Dominator_Html.input([ Dominator_Html_Attributes.class_("toggle"), Dominator_Html_Attributes.type_("checkbox"), Dominator_Html_Attributes.checked(v.completed), Dominator_Html_Events.onClick(new Check(v.id, !v.completed)) ])([  ]), Dominator_Html.label([ Dominator_Html_Events.onDoubleClick(new EditingEntry(v.id, true)) ])([ Dominator_Html.text(v.description) ]), Dominator_Html.button([ Dominator_Html_Attributes.class_("destroy"), Dominator_Html_Events.onClick(new Delete(v.id)) ])([  ]) ]), Dominator_Html.input([ Dominator_Html_Attributes.class_("edit"), Dominator_Html_Attributes.value(v.description), Dominator_Html_Attributes.name("title"), Dominator_Html_Attributes.id("todo-" + Data_Show.show(Data_Show.showInt)(v.id)), Dominator_Html_Events.onInput(UpdateEntry.create(v.id)), Dominator_Html_Events.onBlur(new EditingEntry(v.id, false)), onEnter(new EditingEntry(v.id, false)) ])([  ]) ]);
  };
  var viewInput = function (task) {
      return Dominator_Html.header([ Dominator_Html_Attributes.class_("header") ])([ Dominator_Html.h1([  ])([ Dominator_Html.text("todos") ]), Dominator_Html.input([ Dominator_Html_Attributes.class_("new-todo"), Dominator_Html_Attributes.placeholder("What needs to be done?"), Dominator_Html_Attributes.autofocus(true), Dominator_Html_Attributes.value(task), Dominator_Html_Attributes.name("newTodo"), Dominator_Html_Events.onInput(UpdateField.create), onEnter(Add.value) ])([  ]) ]);
  };
  var newEntry = function (desc) {
      return function (id) {
          return {
              description: desc,
              completed: false,
              editing: false,
              id: id
          };
      };
  };

  // VIEW
  var isCompleted = function (v) {
      return v.completed;
  };

  // -- VIEW CONTROLS AND FOOTER
  var viewControls = function (visibility) {
      return function (entries) {
          var entriesCompleted = Data_List.length(Data_List.filter(isCompleted)(entries));
          var entriesLeft = Data_List.length(entries) - entriesCompleted | 0;
          return Dominator_Html.footer([ Dominator_Html_Attributes.class_("footer"), Dominator_Html_Attributes.hidden(Data_List["null"](entries)) ])([ Dominator_Html_Lazy.lazy(viewControlsCount)(entriesLeft), Dominator_Html_Lazy.lazy(viewControlsFilters)(visibility), Dominator_Html_Lazy.lazy(viewControlsClear)(entriesCompleted) ]);
      };
  };
  var infoFooter = Dominator_Html.footer([ Dominator_Html_Attributes.class_("info") ])([ Dominator_Html.p([  ])([ Dominator_Html.text("Double-click to edit a todo") ]), Dominator_Html.p([  ])([ Dominator_Html.text("Code adapted by "), Dominator_Html.a([ Dominator_Html_Attributes.href("https://github.com/lazamar") ])([ Dominator_Html.text("Marcelo Lazaroni") ]), Dominator_Html.text(" showing Dominator's virtual DOM in Purescript. ") ]), Dominator_Html.p([  ])([ Dominator_Html.text("Originally written by "), Dominator_Html.a([ Dominator_Html_Attributes.href("https://github.com/evancz") ])([ Dominator_Html.text("Evan Czaplicki") ]) ]), Dominator_Html.p([  ])([ Dominator_Html.text("Part of "), Dominator_Html.a([ Dominator_Html_Attributes.href("http://todomvc.com") ])([ Dominator_Html.text("TodoMVC") ]) ]) ]);
  var genericEntry = new Data_Generic.Generic(function (v) {
      if (v instanceof Data_Generic.SProd && (v.value0 === "Todo.Entry" && v.value1.length === 1)) {
          return Control_Apply.apply(Data_Maybe.applyMaybe)(new Data_Maybe.Just(Entry))((function (r) {
              if (r instanceof Data_Generic.SRecord && r.value0.length === 4) {
                  return Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(new Data_Maybe.Just(function (completed1) {
                      return function (description1) {
                          return function (editing1) {
                              return function (id1) {
                                  return {
                                      completed: completed1,
                                      description: description1,
                                      editing: editing1,
                                      id: id1
                                  };
                              };
                          };
                      };
                  }))(Data_Generic.fromSpine(Data_Generic.genericBool)(r["value0"][0].recValue(Data_Unit.unit))))(Data_Generic.fromSpine(Data_Generic.genericString)(r["value0"][1].recValue(Data_Unit.unit))))(Data_Generic.fromSpine(Data_Generic.genericBool)(r["value0"][2].recValue(Data_Unit.unit))))(Data_Generic.fromSpine(Data_Generic.genericInt)(r["value0"][3].recValue(Data_Unit.unit)));
              };
              return Data_Maybe.Nothing.value;
          })(v["value1"][0](Data_Unit.unit)));
      };
      return Data_Maybe.Nothing.value;
  }, function ($dollarq) {
      return new Data_Generic.SigProd("Todo.Entry", [ {
          sigConstructor: "Todo.Entry",
          sigValues: [ function ($dollarq1) {
              return new Data_Generic.SigRecord([ {
                  recLabel: "completed",
                  recValue: function ($dollarq2) {
                      return Data_Generic.toSignature(Data_Generic.genericBool)(Data_Generic.anyProxy);
                  }
              }, {
                  recLabel: "description",
                  recValue: function ($dollarq2) {
                      return Data_Generic.toSignature(Data_Generic.genericString)(Data_Generic.anyProxy);
                  }
              }, {
                  recLabel: "editing",
                  recValue: function ($dollarq2) {
                      return Data_Generic.toSignature(Data_Generic.genericBool)(Data_Generic.anyProxy);
                  }
              }, {
                  recLabel: "id",
                  recValue: function ($dollarq2) {
                      return Data_Generic.toSignature(Data_Generic.genericInt)(Data_Generic.anyProxy);
                  }
              } ]);
          } ]
      } ]);
  }, function (v) {
      return new Data_Generic.SProd("Todo.Entry", [ function ($dollarq) {
          return new Data_Generic.SRecord([ {
              recLabel: "completed",
              recValue: function ($dollarq1) {
                  return Data_Generic.toSpine(Data_Generic.genericBool)(v.completed);
              }
          }, {
              recLabel: "description",
              recValue: function ($dollarq1) {
                  return Data_Generic.toSpine(Data_Generic.genericString)(v.description);
              }
          }, {
              recLabel: "editing",
              recValue: function ($dollarq1) {
                  return Data_Generic.toSpine(Data_Generic.genericBool)(v.editing);
              }
          }, {
              recLabel: "id",
              recValue: function ($dollarq1) {
                  return Data_Generic.toSpine(Data_Generic.genericInt)(v.id);
              }
          } ]);
      } ]);
  });
  var genericModel = new Data_Generic.Generic(function (v) {
      if (v instanceof Data_Generic.SProd && (v.value0 === "Todo.Model" && v.value1.length === 1)) {
          return Control_Apply.apply(Data_Maybe.applyMaybe)(new Data_Maybe.Just(Model))((function (r) {
              if (r instanceof Data_Generic.SRecord && r.value0.length === 4) {
                  return Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(new Data_Maybe.Just(function (entries1) {
                      return function (field1) {
                          return function (uid1) {
                              return function (visibility1) {
                                  return {
                                      entries: entries1,
                                      field: field1,
                                      uid: uid1,
                                      visibility: visibility1
                                  };
                              };
                          };
                      };
                  }))(Data_Generic.fromSpine(Data_Generic.genericList(genericEntry))(r["value0"][0].recValue(Data_Unit.unit))))(Data_Generic.fromSpine(Data_Generic.genericString)(r["value0"][1].recValue(Data_Unit.unit))))(Data_Generic.fromSpine(Data_Generic.genericInt)(r["value0"][2].recValue(Data_Unit.unit))))(Data_Generic.fromSpine(Data_Generic.genericString)(r["value0"][3].recValue(Data_Unit.unit)));
              };
              return Data_Maybe.Nothing.value;
          })(v["value1"][0](Data_Unit.unit)));
      };
      return Data_Maybe.Nothing.value;
  }, function ($dollarq) {
      return new Data_Generic.SigProd("Todo.Model", [ {
          sigConstructor: "Todo.Model",
          sigValues: [ function ($dollarq1) {
              return new Data_Generic.SigRecord([ {
                  recLabel: "entries",
                  recValue: function ($dollarq2) {
                      return Data_Generic.toSignature(Data_Generic.genericList(genericEntry))(Data_Generic.anyProxy);
                  }
              }, {
                  recLabel: "field",
                  recValue: function ($dollarq2) {
                      return Data_Generic.toSignature(Data_Generic.genericString)(Data_Generic.anyProxy);
                  }
              }, {
                  recLabel: "uid",
                  recValue: function ($dollarq2) {
                      return Data_Generic.toSignature(Data_Generic.genericInt)(Data_Generic.anyProxy);
                  }
              }, {
                  recLabel: "visibility",
                  recValue: function ($dollarq2) {
                      return Data_Generic.toSignature(Data_Generic.genericString)(Data_Generic.anyProxy);
                  }
              } ]);
          } ]
      } ]);
  }, function (v) {
      return new Data_Generic.SProd("Todo.Model", [ function ($dollarq) {
          return new Data_Generic.SRecord([ {
              recLabel: "entries",
              recValue: function ($dollarq1) {
                  return Data_Generic.toSpine(Data_Generic.genericList(genericEntry))(v.entries);
              }
          }, {
              recLabel: "field",
              recValue: function ($dollarq1) {
                  return Data_Generic.toSpine(Data_Generic.genericString)(v.field);
              }
          }, {
              recLabel: "uid",
              recValue: function ($dollarq1) {
                  return Data_Generic.toSpine(Data_Generic.genericInt)(v.uid);
              }
          }, {
              recLabel: "visibility",
              recValue: function ($dollarq1) {
                  return Data_Generic.toSpine(Data_Generic.genericString)(v.visibility);
              }
          } ]);
      } ]);
  });
  var entryId = function (v) {
      return v.id;
  };

  // How we update our Model on a given Msg?
  var update = function (msg) {
      return function (v) {
          if (msg instanceof NoOp) {
              return new Data_Tuple.Tuple(v, [  ]);
          };
          if (msg instanceof Add) {
              return new Data_Tuple.Tuple((function () {
                  var $66 = {};
                  for (var $67 in v) {
                      if ({}.hasOwnProperty.call(v, $67)) {
                          $66[$67] = v[$67];
                      };
                  };
                  $66.uid = v.uid + 1 | 0;
                  $66.field = "";
                  $66.entries = (function () {
                      var $65 = Data_String["null"](v.field);
                      if ($65) {
                          return v.entries;
                      };
                      return new Data_List_Types.Cons(newEntry(v.field)(v.uid), v.entries);
                  })();
                  return $66;
              })(), [  ]);
          };
          if (msg instanceof UpdateField) {
              return new Data_Tuple.Tuple((function () {
                  var $69 = {};
                  for (var $70 in v) {
                      if ({}.hasOwnProperty.call(v, $70)) {
                          $69[$70] = v[$70];
                      };
                  };
                  $69.field = msg.value0;
                  return $69;
              })(), [  ]);
          };
          if (msg instanceof EditingEntry) {
              var updateEntry = function (v1) {
                  return Entry((function () {
                      var $74 = v1.id === msg.value0;
                      if ($74) {
                          var $75 = {};
                          for (var $76 in v1) {
                              if ({}.hasOwnProperty.call(v1, $76)) {
                                  $75[$76] = v1[$76];
                              };
                          };
                          $75.editing = msg.value1;
                          return $75;
                      };
                      return v1;
                  })());
              };
              var focus = $foreign.focusElement("todo-" + Data_Show.show(Data_Show.showInt)(msg.value0));
              return new Data_Tuple.Tuple((function () {
                  var $78 = {};
                  for (var $79 in v) {
                      if ({}.hasOwnProperty.call(v, $79)) {
                          $78[$79] = v[$79];
                      };
                  };
                  $78.entries = Data_Functor.map(Data_List_Types.functorList)(updateEntry)(v.entries);
                  return $78;
              })(), [ Control_Monad_Eff_Class.liftEff(Control_Monad_Cont_Trans.monadEffContT(Control_Monad_Eff_Class.monadEffEff))(focus) ]);
          };
          if (msg instanceof UpdateEntry) {
              var updateEntry = function (v1) {
                  return Entry((function () {
                      var $84 = v1.id === msg.value0;
                      if ($84) {
                          var $85 = {};
                          for (var $86 in v1) {
                              if ({}.hasOwnProperty.call(v1, $86)) {
                                  $85[$86] = v1[$86];
                              };
                          };
                          $85.description = msg.value1;
                          return $85;
                      };
                      return v1;
                  })());
              };
              return new Data_Tuple.Tuple((function () {
                  var $88 = {};
                  for (var $89 in v) {
                      if ({}.hasOwnProperty.call(v, $89)) {
                          $88[$89] = v[$89];
                      };
                  };
                  $88.entries = Data_Functor.map(Data_List_Types.functorList)(updateEntry)(v.entries);
                  return $88;
              })(), [  ]);
          };
          if (msg instanceof Delete) {
              return new Data_Tuple.Tuple((function () {
                  var $93 = {};
                  for (var $94 in v) {
                      if ({}.hasOwnProperty.call(v, $94)) {
                          $93[$94] = v[$94];
                      };
                  };
                  $93.entries = Data_List.filter(function (t) {
                      return entryId(t) !== msg.value0;
                  })(v.entries);
                  return $93;
              })(), [  ]);
          };
          if (msg instanceof DeleteComplete) {
              return new Data_Tuple.Tuple((function () {
                  var $97 = {};
                  for (var $98 in v) {
                      if ({}.hasOwnProperty.call(v, $98)) {
                          $97[$98] = v[$98];
                      };
                  };
                  $97.entries = Data_List.filter(function ($131) {
                      return !isCompleted($131);
                  })(v.entries);
                  return $97;
              })(), [  ]);
          };
          if (msg instanceof Check) {
              var updateEntry = function (v1) {
                  return Entry((function () {
                      var $101 = v1.id === msg.value0;
                      if ($101) {
                          var $102 = {};
                          for (var $103 in v1) {
                              if ({}.hasOwnProperty.call(v1, $103)) {
                                  $102[$103] = v1[$103];
                              };
                          };
                          $102.completed = msg.value1;
                          return $102;
                      };
                      return v1;
                  })());
              };
              return new Data_Tuple.Tuple((function () {
                  var $105 = {};
                  for (var $106 in v) {
                      if ({}.hasOwnProperty.call(v, $106)) {
                          $105[$106] = v[$106];
                      };
                  };
                  $105.entries = Data_Functor.map(Data_List_Types.functorList)(updateEntry)(v.entries);
                  return $105;
              })(), [  ]);
          };
          if (msg instanceof CheckAll) {
              var updateEntry = function (v1) {
                  return Entry((function () {
                      var $111 = {};
                      for (var $112 in v1) {
                          if ({}.hasOwnProperty.call(v1, $112)) {
                              $111[$112] = v1[$112];
                          };
                      };
                      $111.completed = msg.value0;
                      return $111;
                  })());
              };
              return new Data_Tuple.Tuple((function () {
                  var $114 = {};
                  for (var $115 in v) {
                      if ({}.hasOwnProperty.call(v, $115)) {
                          $114[$115] = v[$115];
                      };
                  };
                  $114.entries = Data_Functor.map(Data_List_Types.functorList)(updateEntry)(v.entries);
                  return $114;
              })(), [  ]);
          };
          if (msg instanceof ChangeVisibility) {
              return new Data_Tuple.Tuple((function () {
                  var $118 = {};
                  for (var $119 in v) {
                      if ({}.hasOwnProperty.call(v, $119)) {
                          $118[$119] = v[$119];
                      };
                  };
                  $118.visibility = msg.value0;
                  return $118;
              })(), [  ]);
          };
          throw new Error("Failed pattern match at Todo line 159, column 5 - line 232, column 57: " + [ msg.constructor.name ]);
      };
  };

  /**
 * | We want to `setStorage` on every update. This function adds the setStorage
 * command for every step of the update function.
 */  
  var updateWithStorage = function (msg) {
      return function (model) {
          var v = update(msg)(model);
          return new Data_Tuple.Tuple(v.value0, Data_Semigroup.append(Data_Semigroup.semigroupArray)(v.value1)([ Control_Monad_Eff_Class.liftEff(Control_Monad_Cont_Trans.monadEffContT(Control_Monad_Eff_Class.monadEffEff))($foreign.setStorage(v.value0)) ]));
      };
  };

  // VIEW INDIVIDUAL ENTRIES
  var viewKeyedEntry = function (entry) {
      return new Data_Tuple.Tuple(Data_Show.show(Data_Show.showInt)(entryId(entry)), Dominator_Html_Lazy.lazy(viewEntry)(entry));
  };

  // -- -- VIEW ALL ENTRIES
  var viewEntries = function (visibility) {
      return function (entries) {
          var isVisible = function (v) {
              if (visibility === "Completed") {
                  return v.completed;
              };
              if (visibility === "Active") {
                  return !v.completed;
              };
              return true;
          };
          var cssVisibility = (function () {
              var $127 = Data_List["null"](entries);
              if ($127) {
                  return "hidden";
              };
              return "visible";
          })();
          var allCompleted = Data_Foldable.all(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(isCompleted)(entries);
          return Dominator_Html.section([ Dominator_Html_Attributes.class_("main"), Dominator_Html_Attributes.style([ new Data_Tuple.Tuple("visibility", cssVisibility) ]) ])([ Dominator_Html.input([ Dominator_Html_Attributes.class_("toggle-all"), Dominator_Html_Attributes.type_("checkbox"), Dominator_Html_Attributes.name("toggle"), Dominator_Html_Attributes.checked(allCompleted), Dominator_Html_Events.onClick(new CheckAll(!allCompleted)) ])([  ]), Dominator_Html.label([ Dominator_Html_Attributes["for"]("toggle-all") ])([ Dominator_Html.text("Mark all as complete") ]), Dominator_Html_Keyed.ul([ Dominator_Html_Attributes.class_("todo-list") ])(Data_Array.fromFoldable(Data_List_Types.foldableList)(Data_Functor.map(Data_List_Types.functorList)(viewKeyedEntry)(Data_List.filter(isVisible)(entries)))) ]);
      };
  };
  var view = function (v) {
      return Dominator_Html.div([ Dominator_Html_Attributes.class_("todomvc-wrapper"), Dominator_Html_Attributes.style([ new Data_Tuple.Tuple("visibility", "hidden") ]) ])([ Dominator_Html.section([ Dominator_Html_Attributes.class_("todoapp") ])([ Dominator_Html_Lazy.lazy(viewInput)(v.field), Dominator_Html_Lazy.lazy2(viewEntries)(v.visibility)(v.entries), Dominator_Html_Lazy.lazy2(viewControls)(v.visibility)(v.entries) ]), infoFooter ]);
  };
  var emptyModel = {
      entries: Data_Monoid.mempty(Data_List_Types.monoidList),
      visibility: "All",
      field: "",
      uid: 0
  };
  var init = function (maybeModel) {
      if (maybeModel instanceof Data_Maybe.Nothing) {
          return new Data_Tuple.Tuple(emptyModel, [  ]);
      };
      if (maybeModel instanceof Data_Maybe.Just) {
          return new Data_Tuple.Tuple(maybeModel.value0, [  ]);
      };
      throw new Error("Failed pattern match at Todo line 129, column 5 - line 131, column 33: " + [ maybeModel.constructor.name ]);
  };
  var embed = function (el) {
      return function (flags) {
          return Dominator_Html.program(new Data_Maybe.Just(el))({
              init: init(parseFlags(flags)),
              update: updateWithStorage,
              view: view
          });
      };
  };
  exports["embed"] = embed;
  exports["updateWithStorage"] = updateWithStorage;
  exports["Model"] = Model;
  exports["Entry"] = Entry;
  exports["emptyModel"] = emptyModel;
  exports["newEntry"] = newEntry;
  exports["parseFlags"] = parseFlags;
  exports["init"] = init;
  exports["NoOp"] = NoOp;
  exports["UpdateField"] = UpdateField;
  exports["EditingEntry"] = EditingEntry;
  exports["UpdateEntry"] = UpdateEntry;
  exports["Add"] = Add;
  exports["Delete"] = Delete;
  exports["DeleteComplete"] = DeleteComplete;
  exports["Check"] = Check;
  exports["CheckAll"] = CheckAll;
  exports["ChangeVisibility"] = ChangeVisibility;
  exports["update"] = update;
  exports["isCompleted"] = isCompleted;
  exports["entryId"] = entryId;
  exports["view"] = view;
  exports["viewInput"] = viewInput;
  exports["onEnter"] = onEnter;
  exports["viewEntries"] = viewEntries;
  exports["viewKeyedEntry"] = viewKeyedEntry;
  exports["viewEntry"] = viewEntry;
  exports["viewControls"] = viewControls;
  exports["viewControlsCount"] = viewControlsCount;
  exports["viewControlsFilters"] = viewControlsFilters;
  exports["visibilitySwap"] = visibilitySwap;
  exports["viewControlsClear"] = viewControlsClear;
  exports["infoFooter"] = infoFooter;
  exports["genericModel"] = genericModel;
  exports["genericEntry"] = genericEntry;
  exports["setStorage"] = $foreign.setStorage;
  exports["focusElement"] = $foreign.focusElement;
})(PS["Todo"] = PS["Todo"] || {});
