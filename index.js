// Generated by purs bundle 0.11.7
var PS = {};
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  var compose = function (dict) {
      return dict.compose;
  };
  exports["compose"] = compose;
  exports["Semigroupoid"] = Semigroupoid;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS["Control.Semigroupoid"] = PS["Control.Semigroupoid"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        
  var Category = function (Semigroupoid0, id) {
      this.Semigroupoid0 = Semigroupoid0;
      this.id = id;
  };
  var id = function (dict) {
      return dict.id;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["Category"] = Category;
  exports["id"] = id;
  exports["categoryFn"] = categoryFn;
})(PS["Control.Category"] = PS["Control.Category"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS["Data.Boolean"] = PS["Data.Boolean"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Category = PS["Control.Category"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  exports["flip"] = flip;
})(PS["Data.Function"] = PS["Data.Function"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Unit = PS["Data.Unit"];        
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };
  exports["Functor"] = Functor;
  exports["map"] = map;
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];        
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  };                      
  var apply = function (dict) {
      return dict.apply;
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS["Control.Applicative"] = PS["Control.Applicative"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  };                     
  var bind = function (dict) {
      return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (v) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (v1) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(v(v1));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS["Control.Monad"] = PS["Control.Monad"] || {});
(function(exports) {
    "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
    "use strict";

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];        
  var Semigroup = function (append) {
      this.append = append;
  };                                                         
  var semigroupArray = new Semigroup($foreign.concatArray);
  var append = function (dict) {
      return dict.append;
  };
  exports["Semigroup"] = Semigroup;
  exports["append"] = append;
  exports["semigroupArray"] = semigroupArray;
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Function = PS["Data.Function"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var Monoid = function (Semigroup0, mempty) {
      this.Semigroup0 = Semigroup0;
      this.mempty = mempty;
  };       
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["Monoid"] = Monoid;
  exports["mempty"] = mempty;
})(PS["Data.Monoid"] = PS["Data.Monoid"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Control.Monad.Eff"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];        
  var monadEff = new Control_Monad.Monad(function () {
      return applicativeEff;
  }, function () {
      return bindEff;
  });
  var bindEff = new Control_Bind.Bind(function () {
      return applyEff;
  }, $foreign.bindE);
  var applyEff = new Control_Apply.Apply(function () {
      return functorEff;
  }, Control_Monad.ap(monadEff));
  var applicativeEff = new Control_Applicative.Applicative(function () {
      return applyEff;
  }, $foreign.pureE);
  var functorEff = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEff));
  exports["functorEff"] = functorEff;
  exports["applyEff"] = applyEff;
  exports["applicativeEff"] = applicativeEff;
  exports["bindEff"] = bindEff;
  exports["monadEff"] = monadEff;
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Category = PS["Control.Category"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];        
  var MonadEff = function (Monad0, liftEff) {
      this.Monad0 = Monad0;
      this.liftEff = liftEff;
  };
  var monadEffEff = new MonadEff(function () {
      return Control_Monad_Eff.monadEff;
  }, Control_Category.id(Control_Category.categoryFn));
  var liftEff = function (dict) {
      return dict.liftEff;
  };
  exports["liftEff"] = liftEff;
  exports["MonadEff"] = MonadEff;
  exports["monadEffEff"] = monadEffEff;
})(PS["Control.Monad.Eff.Class"] = PS["Control.Monad.Eff.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Prelude = PS["Prelude"];        
  var MonadTrans = function (lift) {
      this.lift = lift;
  };
  var lift = function (dict) {
      return dict.lift;
  };
  exports["lift"] = lift;
  exports["MonadTrans"] = MonadTrans;
})(PS["Control.Monad.Trans.Class"] = PS["Control.Monad.Trans.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Newtype = PS["Data.Newtype"];
  var Prelude = PS["Prelude"];
  var monadTransContT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function (m) {
          return function (k) {
              return Control_Bind.bind(dictMonad.Bind1())(m)(k);
          };
      };
  });
  var functorContT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return function (k) {
                  return v(function (a) {
                      return k(f(a));
                  });
              };
          };
      });
  };
  var applyContT = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorContT(dictApply.Functor0());
      }, function (v) {
          return function (v1) {
              return function (k) {
                  return v(function (g) {
                      return v1(function (a) {
                          return k(g(a));
                      });
                  });
              };
          };
      });
  };
  var bindContT = function (dictBind) {
      return new Control_Bind.Bind(function () {
          return applyContT(dictBind.Apply0());
      }, function (v) {
          return function (k) {
              return function (k$prime) {
                  return v(function (a) {
                      var v1 = k(a);
                      return v1(k$prime);
                  });
              };
          };
      });
  };
  var applicativeContT = function (dictApplicative) {
      return new Control_Applicative.Applicative(function () {
          return applyContT(dictApplicative.Apply0());
      }, function (a) {
          return function (k) {
              return k(a);
          };
      });
  };
  var monadContT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeContT(dictMonad.Applicative0());
      }, function () {
          return bindContT(dictMonad.Bind1());
      });
  };
  var monadEffContT = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadContT(dictMonadEff.Monad0());
      }, function ($46) {
          return Control_Monad_Trans_Class.lift(monadTransContT)(dictMonadEff.Monad0())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($46));
      });
  };
  exports["functorContT"] = functorContT;
  exports["applyContT"] = applyContT;
  exports["applicativeContT"] = applicativeContT;
  exports["bindContT"] = bindContT;
  exports["monadContT"] = monadContT;
  exports["monadTransContT"] = monadTransContT;
  exports["monadEffContT"] = monadEffContT;
})(PS["Control.Monad.Cont.Trans"] = PS["Control.Monad.Cont.Trans"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Foldable"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Endo = PS["Data.Monoid.Endo"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var foldl = function (dict) {
      return dict.foldl;
  };
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  exports["Foldable"] = Foldable;
  exports["foldr"] = foldr;
  exports["foldl"] = foldl;
  exports["foldMap"] = foldMap;
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
    "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.Show"];     
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showInt = new Show($foreign.showIntImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showInt"] = showInt;
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Distributive = PS["Data.Distributive"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var Type_Equality = PS["Type.Equality"];        
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  exports["Tuple"] = Tuple;
})(PS["Data.Tuple"] = PS["Data.Tuple"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_FoldableWithIndex = PS["Data.FoldableWithIndex"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_FunctorWithIndex = PS["Data.FunctorWithIndex"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = PS["Data.Semigroup.Foldable"];
  var Data_Semigroup_Traversable = PS["Data.Semigroup.Traversable"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_TraversableWithIndex = PS["Data.TraversableWithIndex"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];        
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var foldableList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return Data_Foldable.foldl(foldableList)(function (acc) {
              return function ($158) {
                  return Data_Semigroup.append(dictMonoid.Semigroup0())(acc)(f($158));
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  }, function (f) {
      var go = function ($copy_b) {
          return function ($copy_v) {
              var $tco_var_b = $copy_b;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(b, v) {
                  if (v instanceof Nil) {
                      $tco_done = true;
                      return b;
                  };
                  if (v instanceof Cons) {
                      $tco_var_b = f(b)(v.value0);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List.Types line 81, column 12 - line 83, column 30: " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_b, $copy_v);
              };
              return $tco_result;
          };
      };
      return go;
  }, function (f) {
      return function (b) {
          var rev = Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value);
          return function ($159) {
              return Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b)(rev($159));
          };
      };
  });
  var functorList = new Data_Functor.Functor(function (f) {
      return Data_Foldable.foldr(foldableList)(function (x) {
          return function (acc) {
              return new Cons(f(x), acc);
          };
      })(Nil.value);
  });
  var semigroupList = new Data_Semigroup.Semigroup(function (xs) {
      return function (ys) {
          return Data_Foldable.foldr(foldableList)(Cons.create)(ys)(xs);
      };
  });
  var monoidList = new Data_Monoid.Monoid(function () {
      return semigroupList;
  }, Nil.value);
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["semigroupList"] = semigroupList;
  exports["monoidList"] = monoidList;
  exports["functorList"] = functorList;
  exports["foldableList"] = foldableList;
})(PS["Data.List.Types"] = PS["Data.List.Types"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_FunctorWithIndex = PS["Data.FunctorWithIndex"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var reverse = (function () {
      var go = function ($copy_acc) {
          return function ($copy_v) {
              var $tco_var_acc = $copy_acc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(acc, v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return acc;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List line 368, column 3 - line 368, column 19: " + [ acc.constructor.name, v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_acc, $copy_v);
              };
              return $tco_result;
          };
      };
      return go(Data_List_Types.Nil.value);
  })();
  var filter = function (p) {
      var go = function ($copy_acc) {
          return function ($copy_v) {
              var $tco_var_acc = $copy_acc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(acc, v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return reverse(acc);
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (p(v.value0)) {
                          $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);
                          $copy_v = v.value1;
                          return;
                      };
                      if (Data_Boolean.otherwise) {
                          $tco_var_acc = acc;
                          $copy_v = v.value1;
                          return;
                      };
                  };
                  throw new Error("Failed pattern match at Data.List line 390, column 3 - line 390, column 27: " + [ acc.constructor.name, v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_acc, $copy_v);
              };
              return $tco_result;
          };
      };
      return go(Data_List_Types.Nil.value);
  };
  exports["reverse"] = reverse;
  exports["filter"] = filter;
})(PS["Data.List"] = PS["Data.List"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Data.String"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_String_Unsafe = PS["Data.String.Unsafe"];
  var Prelude = PS["Prelude"];
  var $$null = function (s) {
      return s === "";
  };
  exports["null"] = $$null;
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {/* eslint-disable no-use-before-define */

  function F5(fn) {
      return function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return fn(a, b, c, d, e);
                      };
                  };
              };
          };
      };
  }

  function runOnce(fn) {
      var called = false;
      return function() {
          if (called) {
              return;
          }
          called = true;
          return fn.apply(null, arguments);
      };
  }

  function dispatchCmds(cmds, enqueue) {
      var i;
      var length = cmds.length;
      for (i = 0; i < length; i++) {
          var f = cmds[i];
          var run = function() {
              f(runOnce(enqueue))();
          };

          setTimeout(run, 0);
      }
  }

  function program(scheduler, normalRenderer, init, update, view) {
      // -- create renderer --

      return function() {
          var parentNode = document.createElement("div");
          document.body.appendChild(parentNode);

          var initialModel = init.value0;
          var initialCmds = init.value1;

          var renderer = normalRenderer(parentNode, view);
          var updateView = renderer(enqueue, initialModel);
          // ---------------------
          var model = initialModel;

          function onMessage(msg) {
              var tup = update(msg)(model);
              model = tup.value0;
              var cmds = tup.value1;
              updateView(model);
              dispatchCmds(cmds, enqueue);
          }

          var mainProcess = scheduler.spawn(onMessage);
          dispatchCmds(initialCmds, enqueue);

          function enqueue(msg) {
              scheduler.send(mainProcess, msg);
              return function() {};
          }
      };
  }

  exports.program = F5(program);
})(PS["Elm.Native.Platform"] = PS["Elm.Native.Platform"] || {});
(function(exports) {/* eslint-disable no-use-before-define, complexity */

  var scheduler = (function() {
      var working = false;
      var workQueue = [];
      var pid = 0;

      // Maximum number of times that we will run entire updates
      // consecutively. If we hit the max it means that we are
      // propbably in a loop
      var MAX_STEPS = 10000;

      // Create a process
      function spawn(onMessage) {
          var process = {
              id: ++pid,
              onMessage: onMessage,
              messageQueue: []
          };

          return process;
      }

      // Send a msg to a process
      function send(process, msg) {
          process.messageQueue.push(msg);
          enqueue(process);
      }

      function enqueue(msg) {
          workQueue.push(msg);

          if (!working) {
              setTimeout(work, 0);
              working = true;
          }
      }

      function work() {
          var process;
          var steps = 0;

          while (steps < MAX_STEPS && (process = workQueue.shift())) {
              var msg;
              if ((msg = process.messageQueue.shift())) {
                  process.onMessage(msg);
              }
              steps = steps + 1;
          }

          if (!msg) {
              working = false;
              return;
          }
          setTimeout(work, 0);
      }

      return {
          spawn: spawn,
          send: send
      };
  })();

  exports.scheduler = scheduler;
})(PS["Elm.Native.Scheduler"] = PS["Elm.Native.Scheduler"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Elm.Native.Scheduler"];
  exports["scheduler"] = $foreign.scheduler;
})(PS["Elm.Native.Scheduler"] = PS["Elm.Native.Scheduler"] || {});
(function(exports) {/* globals  
    _elm_lang$core$Native_Utils, 
    _elm_lang$core$Json_Decode$map,
    _elm_lang$core$Platform_Cmd$none,
    _elm_lang$core$Platform_Sub$none,
    _elm_lang$core$Native_Platform,
    _elm_lang$core$Native_Scheduler
*/  
  /* eslint-disable no-unused-vars, no-use-before-define, no-redeclare, complexity, max-len */
  // Compiler functions

  function F(arity, fun, wrapper) {
      wrapper.a = arity;
      wrapper.f = fun;
      return wrapper;
  }

  function F2(fun) {
      return F(2, fun, function(a) {
          return function(b) {
              return fun(a, b);
          };
      });
  }
  function F3(fun) {
      return F(3, fun, function(a) {
          return function(b) {
              return function(c) {
                  return fun(a, b, c);
              };
          };
      });
  }
  function F4(fun) {
      return F(4, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return fun(a, b, c, d);
                  };
              };
          };
      });
  }
  function F5(fun) {
      return F(5, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return fun(a, b, c, d, e);
                      };
                  };
              };
          };
      });
  }
  function F6(fun) {
      return F(6, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return fun(a, b, c, d, e, f);
                          };
                      };
                  };
              };
          };
      });
  }
  function F7(fun) {
      return F(7, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return function(g) {
                                  return fun(a, b, c, d, e, f, g);
                              };
                          };
                      };
                  };
              };
          };
      });
  }
  function F8(fun) {
      return F(8, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return function(g) {
                                  return function(h) {
                                      return fun(a, b, c, d, e, f, g, h);
                                  };
                              };
                          };
                      };
                  };
              };
          };
      });
  }
  function F9(fun) {
      return F(9, fun, function(a) {
          return function(b) {
              return function(c) {
                  return function(d) {
                      return function(e) {
                          return function(f) {
                              return function(g) {
                                  return function(h) {
                                      return function(i) {
                                          return fun(a, b, c, d, e, f, g, h, i);
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      });
  }

  function A2(fun, a, b) {
      return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
  }
  function A3(fun, a, b, c) {
      return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
  }
  function A4(fun, a, b, c, d) {
      return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
  }
  function A5(fun, a, b, c, d, e) {
      return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
  }
  function A6(fun, a, b, c, d, e, f) {
      return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
  }
  function A7(fun, a, b, c, d, e, f, g) {
      return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
  }
  function A8(fun, a, b, c, d, e, f, g, h) {
      return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
  }
  function A9(fun, a, b, c, d, e, f, g, h, i) {
      return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
  }

  window._elm_lang$core$Native_Core = {
      F2: F2,
      F3: F3,
      F4: F4,
      F5: F5,
      F6: F6,
      F7: F7,
      F8: F8,
      F9: F9,
      A2: A2,
      A3: A3,
      A4: A4,
      A5: A5,
      A6: A6,
      A7: A7,
      A8: A8,
      A9: A9
  };

  // =============================================================
  // VIRTUAL DOM
  // =============================================================

  var _elm_lang$virtual_dom$VirtualDom_Debug$wrap;
  var _elm_lang$virtual_dom$VirtualDom_Debug$wrapWithFlags;

  var _elm_lang$virtual_dom$Native_VirtualDom = (function() {
      var STYLE_KEY = "STYLE";
      var EVENT_KEY = "EVENT";
      var ATTR_KEY = "ATTR";
      var ATTR_NS_KEY = "ATTR_NS";

      var localDoc = typeof document !== "undefined" ? document : {};

      ////////////  VIRTUAL DOM NODES  ////////////

      function text(string) {
          return {
              type: "text",
              text: string
          };
      }

      function node(tag) {
          return F2(function(factList, kidList) {
              return nodeHelp(tag, factList, kidList);
          });
      }

      function nodeHelp(tag, factList, kidList) {
          var organized = organizeFacts(factList);
          var namespace = organized.namespace;
          var facts = organized.facts;

          var children = [];
          var descendantsCount = 0;
          while (kidList.constructor.name !== "Nil") {
              var kid = kidList.value0;
              descendantsCount += kid.descendantsCount || 0;
              children.push(kid);
              kidList = kidList.value1;
          }
          descendantsCount += children.length;

          return {
              type: "node",
              tag: tag,
              facts: facts,
              children: children,
              namespace: namespace,
              descendantsCount: descendantsCount
          };
      }

      function keyedNode(tag, factList, kidList) {
          var organized = organizeFacts(factList);
          var namespace = organized.namespace;
          var facts = organized.facts;

          var children = [];
          var descendantsCount = 0;
          while (kidList.constructor.name !== "Nil") {
              var kid = kidList.value0;
              descendantsCount += kid.value1.descendantsCount || 0;
              children.push(kid);
              kidList = kidList.value1;
          }
          descendantsCount += children.length;

          return {
              type: "keyed-node",
              tag: tag,
              facts: facts,
              children: children,
              namespace: namespace,
              descendantsCount: descendantsCount
          };
      }

      function custom(factList, model, impl) {
          var facts = organizeFacts(factList).facts;

          return {
              type: "custom",
              facts: facts,
              model: model,
              impl: impl
          };
      }

      function map(tagger, node) {
          return {
              type: "tagger",
              tagger: tagger,
              node: node,
              descendantsCount: 1 + (node.descendantsCount || 0)
          };
      }

      function thunk(func, args, thunk) {
          return {
              type: "thunk",
              func: func,
              args: args,
              thunk: thunk,
              node: undefined
          };
      }

      function lazy(fn, a) {
          return thunk(fn, [a], function() {
              return fn(a);
          });
      }

      function lazy2(fn, a, b) {
          return thunk(fn, [a, b], function() {
              return A2(fn, a, b);
          });
      }

      function lazy3(fn, a, b, c) {
          return thunk(fn, [a, b, c], function() {
              return A3(fn, a, b, c);
          });
      }

      // FACTS

      function organizeFacts(factList) {
          var namespace,
              facts = {};

          while (factList.constructor.name !== "Nil") {
              var entry = factList.value0;
              var key = entry.key;

              if (key === ATTR_KEY || key === ATTR_NS_KEY || key === EVENT_KEY) {
                  var subFacts = facts[key] || {};
                  subFacts[entry.realKey] = entry.value;
                  facts[key] = subFacts;
              } else if (key === STYLE_KEY) {
                  var styles = facts[key] || {};
                  var styleList = entry.value;
                  while (styleList.constructor.name !== "Nil") {
                      var style = styleList.value0;
                      styles[style.value0] = style.value1;
                      styleList = styleList.value1;
                  }
                  facts[key] = styles;
              } else if (key === "namespace") {
                  namespace = entry.value;
              } else if (key === "className") {
                  var classes = facts[key];
                  facts[key] =
                      typeof classes === "undefined" ? entry.value : classes + " " + entry.value;
              } else {
                  facts[key] = entry.value;
              }
              factList = factList.value1;
          }

          return {
              facts: facts,
              namespace: namespace
          };
      }

      ////////////  PROPERTIES AND ATTRIBUTES  ////////////

      function style(value) {
          return {
              key: STYLE_KEY,
              value: value
          };
      }

      function property(key, value) {
          return {
              key: key,
              value: value
          };
      }

      function attribute(key, value) {
          return {
              key: ATTR_KEY,
              realKey: key,
              value: value
          };
      }

      function attributeNS(namespace, key, value) {
          return {
              key: ATTR_NS_KEY,
              realKey: key,
              value: {
                  value: value,
                  namespace: namespace
              }
          };
      }

      function on(name, options, decoder) {
          return {
              key: EVENT_KEY,
              realKey: name,
              value: {
                  options: options,
                  decoder: decoder
              }
          };
      }

      function equalEvents(a, b) {
          if (a.options !== b.options) {
              if (
                  a.options.stopPropagation !== b.options.stopPropagation ||
                  a.options.preventDefault !== b.options.preventDefault
              ) {
                  return false;
              }
          }
          return window._elm_lang$core$Native_Json.equality(a.decoder, b.decoder);
      }

      function mapProperty(func, property) {
          if (property.key !== EVENT_KEY) {
              return property;
          }
          return on(
              property.realKey,
              property.value.options,
              A2(_elm_lang$core$Json_Decode$map, func, property.value.decoder)
          );
      }

      ////////////  RENDER  ////////////

      function render(vNode, eventNode) {
          switch (vNode.type) {
              case "thunk":
                  if (!vNode.node) {
                      vNode.node = vNode.thunk();
                  }
                  return render(vNode.node, eventNode);

              case "tagger":
                  var subNode = vNode.node;
                  var tagger = vNode.tagger;

                  while (subNode.type === "tagger") {
                      typeof tagger !== "object"
                          ? (tagger = [tagger, subNode.tagger])
                          : tagger.push(subNode.tagger);

                      subNode = subNode.node;
                  }

                  var subEventRoot = { tagger: tagger, parent: eventNode };
                  var domNode = render(subNode, subEventRoot);
                  domNode.elm_event_node_ref = subEventRoot;
                  return domNode;

              case "text":
                  return localDoc.createTextNode(vNode.text);

              case "node":
                  var domNode = vNode.namespace
                      ? localDoc.createElementNS(vNode.namespace, vNode.tag)
                      : localDoc.createElement(vNode.tag);

                  applyFacts(domNode, eventNode, vNode.facts);

                  var children = vNode.children;

                  for (var i = 0; i < children.length; i++) {
                      domNode.appendChild(render(children[i], eventNode));
                  }

                  return domNode;

              case "keyed-node":
                  var domNode = vNode.namespace
                      ? localDoc.createElementNS(vNode.namespace, vNode.tag)
                      : localDoc.createElement(vNode.tag);

                  applyFacts(domNode, eventNode, vNode.facts);

                  var children = vNode.children;

                  for (var i = 0; i < children.length; i++) {
                      domNode.appendChild(render(children[i].value1, eventNode));
                  }

                  return domNode;

              case "custom":
                  var domNode = vNode.impl.render(vNode.model);
                  applyFacts(domNode, eventNode, vNode.facts);
                  return domNode;
          }
      }

      ////////////  APPLY FACTS  ////////////

      function applyFacts(domNode, eventNode, facts) {
          for (var key in facts) {
              var value = facts[key];

              switch (key) {
                  case STYLE_KEY:
                      applyStyles(domNode, value);
                      break;

                  case EVENT_KEY:
                      applyEvents(domNode, eventNode, value);
                      break;

                  case ATTR_KEY:
                      applyAttrs(domNode, value);
                      break;

                  case ATTR_NS_KEY:
                      applyAttrsNS(domNode, value);
                      break;

                  case "value":
                      if (domNode[key] !== value) {
                          domNode[key] = value;
                      }
                      break;

                  default:
                      domNode[key] = value;
                      break;
              }
          }
      }

      function applyStyles(domNode, styles) {
          var domNodeStyle = domNode.style;

          for (var key in styles) {
              domNodeStyle[key] = styles[key];
          }
      }

      function applyEvents(domNode, eventNode, events) {
          var allHandlers = domNode.elm_handlers || {};

          for (var key in events) {
              var handler = allHandlers[key];
              var value = events[key];

              if (typeof value === "undefined") {
                  domNode.removeEventListener(key, handler);
                  allHandlers[key] = undefined;
              } else if (typeof handler === "undefined") {
                  var handler = makeEventHandler(eventNode, value);
                  domNode.addEventListener(key, handler);
                  allHandlers[key] = handler;
              } else {
                  handler.info = value;
              }
          }

          domNode.elm_handlers = allHandlers;
      }

      function makeEventHandler(eventNode, info) {
          function eventHandler(event) {
              var info = eventHandler.info;

              var value = A2(window._elm_lang$core$Native_Json.run, info.decoder, event);

              if (value.ctor === "Ok") {
                  var options = info.options;
                  if (options.stopPropagation) {
                      event.stopPropagation();
                  }
                  if (options.preventDefault) {
                      event.preventDefault();
                  }

                  var message = value.value0;

                  var currentEventNode = eventNode;
                  while (currentEventNode) {
                      var tagger = currentEventNode.tagger;
                      if (typeof tagger === "function") {
                          message = tagger(message);
                      } else {
                          for (var i = tagger.length; i--; ) {
                              message = tagger[i](message);
                          }
                      }
                      currentEventNode = currentEventNode.parent;
                  }
              }
          }

          eventHandler.info = info;

          return eventHandler;
      }

      function applyAttrs(domNode, attrs) {
          for (var key in attrs) {
              var value = attrs[key];
              if (typeof value === "undefined") {
                  domNode.removeAttribute(key);
              } else {
                  domNode.setAttribute(key, value);
              }
          }
      }

      function applyAttrsNS(domNode, nsAttrs) {
          for (var key in nsAttrs) {
              var pair = nsAttrs[key];
              var namespace = pair.namespace;
              var value = pair.value;

              if (typeof value === "undefined") {
                  domNode.removeAttributeNS(namespace, key);
              } else {
                  domNode.setAttributeNS(namespace, key, value);
              }
          }
      }

      ////////////  DIFF  ////////////

      function diff(a, b) {
          var patches = [];
          diffHelp(a, b, patches, 0);
          return patches;
      }

      function makePatch(type, index, data) {
          return {
              index: index,
              type: type,
              data: data,
              domNode: undefined,
              eventNode: undefined
          };
      }

      function diffHelp(a, b, patches, index) {
          if (a === b) {
              return;
          }

          var aType = a.type;
          var bType = b.type;

          // Bail if you run into different types of nodes. Implies that the
          // structure has changed significantly and it's not worth a diff.
          if (aType !== bType) {
              patches.push(makePatch("p-redraw", index, b));
              return;
          }

          // Now we know that both nodes are the same type.
          switch (bType) {
              case "thunk":
                  var aArgs = a.args;
                  var bArgs = b.args;
                  var i = aArgs.length;
                  var same = a.func === b.func && i === bArgs.length;
                  while (same && i--) {
                      same = aArgs[i] === bArgs[i];
                  }
                  if (same) {
                      b.node = a.node;
                      return;
                  }
                  b.node = b.thunk();
                  var subPatches = [];
                  diffHelp(a.node, b.node, subPatches, 0);
                  if (subPatches.length > 0) {
                      patches.push(makePatch("p-thunk", index, subPatches));
                  }
                  return;

              case "tagger":
                  // gather nested taggers
                  var aTaggers = a.tagger;
                  var bTaggers = b.tagger;
                  var nesting = false;

                  var aSubNode = a.node;
                  while (aSubNode.type === "tagger") {
                      nesting = true;

                      typeof aTaggers !== "object"
                          ? (aTaggers = [aTaggers, aSubNode.tagger])
                          : aTaggers.push(aSubNode.tagger);

                      aSubNode = aSubNode.node;
                  }

                  var bSubNode = b.node;
                  while (bSubNode.type === "tagger") {
                      nesting = true;

                      typeof bTaggers !== "object"
                          ? (bTaggers = [bTaggers, bSubNode.tagger])
                          : bTaggers.push(bSubNode.tagger);

                      bSubNode = bSubNode.node;
                  }

                  // Just bail if different numbers of taggers. This implies the
                  // structure of the virtual DOM has changed.
                  if (nesting && aTaggers.length !== bTaggers.length) {
                      patches.push(makePatch("p-redraw", index, b));
                      return;
                  }

                  // check if taggers are "the same"
                  if (nesting ? !pairwiseRefEqual(aTaggers, bTaggers) : aTaggers !== bTaggers) {
                      patches.push(makePatch("p-tagger", index, bTaggers));
                  }

                  // diff everything below the taggers
                  diffHelp(aSubNode, bSubNode, patches, index + 1);
                  return;

              case "text":
                  if (a.text !== b.text) {
                      patches.push(makePatch("p-text", index, b.text));
                      return;
                  }

                  return;

              case "node":
                  // Bail if obvious indicators have changed. Implies more serious
                  // structural changes such that it's not worth it to diff.
                  if (a.tag !== b.tag || a.namespace !== b.namespace) {
                      patches.push(makePatch("p-redraw", index, b));
                      return;
                  }

                  var factsDiff = diffFacts(a.facts, b.facts);

                  if (typeof factsDiff !== "undefined") {
                      patches.push(makePatch("p-facts", index, factsDiff));
                  }

                  diffChildren(a, b, patches, index);
                  return;

              case "keyed-node":
                  // Bail if obvious indicators have changed. Implies more serious
                  // structural changes such that it's not worth it to diff.
                  if (a.tag !== b.tag || a.namespace !== b.namespace) {
                      patches.push(makePatch("p-redraw", index, b));
                      return;
                  }

                  var factsDiff = diffFacts(a.facts, b.facts);

                  if (typeof factsDiff !== "undefined") {
                      patches.push(makePatch("p-facts", index, factsDiff));
                  }

                  diffKeyedChildren(a, b, patches, index);
                  return;

              case "custom":
                  if (a.impl !== b.impl) {
                      patches.push(makePatch("p-redraw", index, b));
                      return;
                  }

                  var factsDiff = diffFacts(a.facts, b.facts);
                  if (typeof factsDiff !== "undefined") {
                      patches.push(makePatch("p-facts", index, factsDiff));
                  }

                  var patch = b.impl.diff(a, b);
                  if (patch) {
                      patches.push(makePatch("p-custom", index, patch));
                      return;
                  }

                  return;
          }
      }

      // assumes the incoming arrays are the same length
      function pairwiseRefEqual(as, bs) {
          for (var i = 0; i < as.length; i++) {
              if (as[i] !== bs[i]) {
                  return false;
              }
          }

          return true;
      }

      // TODO Instead of creating a new diff object, it's possible to just test if
      // there *is* a diff. During the actual patch, do the diff again and make the
      // modifications directly. This way, there's no new allocations. Worth it?
      function diffFacts(a, b, category) {
          var diff;

          // look for changes and removals
          for (var aKey in a) {
              if (
                  aKey === STYLE_KEY ||
                  aKey === EVENT_KEY ||
                  aKey === ATTR_KEY ||
                  aKey === ATTR_NS_KEY
              ) {
                  var subDiff = diffFacts(a[aKey], b[aKey] || {}, aKey);
                  if (subDiff) {
                      diff = diff || {};
                      diff[aKey] = subDiff;
                  }
                  continue;
              }

              // remove if not in the new facts
              if (!(aKey in b)) {
                  diff = diff || {};
                  diff[aKey] =
                      typeof category === "undefined"
                          ? typeof a[aKey] === "string" ? "" : null
                          : category === STYLE_KEY
                              ? ""
                              : category === EVENT_KEY || category === ATTR_KEY
                                  ? undefined
                                  : { namespace: a[aKey].namespace, value: undefined };

                  continue;
              }

              var aValue = a[aKey];
              var bValue = b[aKey];

              // reference equal, so don't worry about it
              if (
                  (aValue === bValue && aKey !== "value") ||
                  (category === EVENT_KEY && equalEvents(aValue, bValue))
              ) {
                  continue;
              }

              diff = diff || {};
              diff[aKey] = bValue;
          }

          // add new stuff
          for (var bKey in b) {
              if (!(bKey in a)) {
                  diff = diff || {};
                  diff[bKey] = b[bKey];
              }
          }

          return diff;
      }

      function diffChildren(aParent, bParent, patches, rootIndex) {
          var aChildren = aParent.children;
          var bChildren = bParent.children;

          var aLen = aChildren.length;
          var bLen = bChildren.length;

          // FIGURE OUT IF THERE ARE INSERTS OR REMOVALS

          if (aLen > bLen) {
              patches.push(makePatch("p-remove-last", rootIndex, aLen - bLen));
          } else if (aLen < bLen) {
              patches.push(makePatch("p-append", rootIndex, bChildren.slice(aLen)));
          }

          // PAIRWISE DIFF EVERYTHING ELSE

          var index = rootIndex;
          var minLen = aLen < bLen ? aLen : bLen;
          for (var i = 0; i < minLen; i++) {
              index++;
              var aChild = aChildren[i];
              diffHelp(aChild, bChildren[i], patches, index);
              index += aChild.descendantsCount || 0;
          }
      }

      ////////////  KEYED DIFF  ////////////

      function diffKeyedChildren(aParent, bParent, patches, rootIndex) {
          var localPatches = [];

          var changes = {}; // Dict String Entry
          var inserts = []; // Array { index : Int, entry : Entry }
          // type Entry = { tag : String, vnode : VNode, index : Int, data : _ }

          var aChildren = aParent.children;
          var bChildren = bParent.children;
          var aLen = aChildren.length;
          var bLen = bChildren.length;
          var aIndex = 0;
          var bIndex = 0;

          var index = rootIndex;

          while (aIndex < aLen && bIndex < bLen) {
              var a = aChildren[aIndex];
              var b = bChildren[bIndex];

              var aKey = a.value0;
              var bKey = b.value0;
              var aNode = a.value1;
              var bNode = b.value1;

              // check if keys match

              if (aKey === bKey) {
                  index++;
                  diffHelp(aNode, bNode, localPatches, index);
                  index += aNode.descendantsCount || 0;

                  aIndex++;
                  bIndex++;
                  continue;
              }

              // look ahead 1 to detect insertions and removals.

              var aLookAhead = aIndex + 1 < aLen;
              var bLookAhead = bIndex + 1 < bLen;

              if (aLookAhead) {
                  var aNext = aChildren[aIndex + 1];
                  var aNextKey = aNext.value0;
                  var aNextNode = aNext.value1;
                  var oldMatch = bKey === aNextKey;
              }

              if (bLookAhead) {
                  var bNext = bChildren[bIndex + 1];
                  var bNextKey = bNext.value0;
                  var bNextNode = bNext.value1;
                  var newMatch = aKey === bNextKey;
              }

              // swap a and b
              if (aLookAhead && bLookAhead && newMatch && oldMatch) {
                  index++;
                  diffHelp(aNode, bNextNode, localPatches, index);
                  insertNode(changes, localPatches, aKey, bNode, bIndex, inserts);
                  index += aNode.descendantsCount || 0;

                  index++;
                  removeNode(changes, localPatches, aKey, aNextNode, index);
                  index += aNextNode.descendantsCount || 0;

                  aIndex += 2;
                  bIndex += 2;
                  continue;
              }

              // insert b
              if (bLookAhead && newMatch) {
                  index++;
                  insertNode(changes, localPatches, bKey, bNode, bIndex, inserts);
                  diffHelp(aNode, bNextNode, localPatches, index);
                  index += aNode.descendantsCount || 0;

                  aIndex += 1;
                  bIndex += 2;
                  continue;
              }

              // remove a
              if (aLookAhead && oldMatch) {
                  index++;
                  removeNode(changes, localPatches, aKey, aNode, index);
                  index += aNode.descendantsCount || 0;

                  index++;
                  diffHelp(aNextNode, bNode, localPatches, index);
                  index += aNextNode.descendantsCount || 0;

                  aIndex += 2;
                  bIndex += 1;
                  continue;
              }

              // remove a, insert b
              if (aLookAhead && bLookAhead && aNextKey === bNextKey) {
                  index++;
                  removeNode(changes, localPatches, aKey, aNode, index);
                  insertNode(changes, localPatches, bKey, bNode, bIndex, inserts);
                  index += aNode.descendantsCount || 0;

                  index++;
                  diffHelp(aNextNode, bNextNode, localPatches, index);
                  index += aNextNode.descendantsCount || 0;

                  aIndex += 2;
                  bIndex += 2;
                  continue;
              }

              break;
          }

          // eat up any remaining nodes with removeNode and insertNode

          while (aIndex < aLen) {
              index++;
              var a = aChildren[aIndex];
              var aNode = a.value1;
              removeNode(changes, localPatches, a.value0, aNode, index);
              index += aNode.descendantsCount || 0;
              aIndex++;
          }

          var endInserts;
          while (bIndex < bLen) {
              endInserts = endInserts || [];
              var b = bChildren[bIndex];
              insertNode(changes, localPatches, b.value0, b.value1, undefined, endInserts);
              bIndex++;
          }

          if (localPatches.length > 0 || inserts.length > 0 || typeof endInserts !== "undefined") {
              patches.push(
                  makePatch("p-reorder", rootIndex, {
                      patches: localPatches,
                      inserts: inserts,
                      endInserts: endInserts
                  })
              );
          }
      }

      ////////////  CHANGES FROM KEYED DIFF  ////////////

      var POSTFIX = "_elmW6BL";

      function insertNode(changes, localPatches, key, vnode, bIndex, inserts) {
          var entry = changes[key];

          // never seen this key before
          if (typeof entry === "undefined") {
              entry = {
                  tag: "insert",
                  vnode: vnode,
                  index: bIndex,
                  data: undefined
              };

              inserts.push({ index: bIndex, entry: entry });
              changes[key] = entry;

              return;
          }

          // this key was removed earlier, a match!
          if (entry.tag === "remove") {
              inserts.push({ index: bIndex, entry: entry });

              entry.tag = "move";
              var subPatches = [];
              diffHelp(entry.vnode, vnode, subPatches, entry.index);
              entry.index = bIndex;
              entry.data.data = {
                  patches: subPatches,
                  entry: entry
              };

              return;
          }

          // this key has already been inserted or moved, a duplicate!
          insertNode(changes, localPatches, key + POSTFIX, vnode, bIndex, inserts);
      }

      function removeNode(changes, localPatches, key, vnode, index) {
          var entry = changes[key];

          // never seen this key before
          if (typeof entry === "undefined") {
              var patch = makePatch("p-remove", index, undefined);
              localPatches.push(patch);

              changes[key] = {
                  tag: "remove",
                  vnode: vnode,
                  index: index,
                  data: patch
              };

              return;
          }

          // this key was inserted earlier, a match!
          if (entry.tag === "insert") {
              entry.tag = "move";
              var subPatches = [];
              diffHelp(vnode, entry.vnode, subPatches, index);

              var patch = makePatch("p-remove", index, {
                  patches: subPatches,
                  entry: entry
              });
              localPatches.push(patch);

              return;
          }

          // this key has already been removed or moved, a duplicate!
          removeNode(changes, localPatches, key + POSTFIX, vnode, index);
      }

      ////////////  ADD DOM NODES  ////////////
      //
      // Each DOM node has an "index" assigned in order of traversal. It is important
      // to minimize our crawl over the actual DOM, so these indexes (along with the
      // descendantsCount of virtual nodes) let us skip touching entire subtrees of
      // the DOM if we know there are no patches there.

      function addDomNodes(domNode, vNode, patches, eventNode) {
          addDomNodesHelp(domNode, vNode, patches, 0, 0, vNode.descendantsCount, eventNode);
      }

      // assumes `patches` is non-empty and indexes increase monotonically.
      function addDomNodesHelp(domNode, vNode, patches, i, low, high, eventNode) {
          var patch = patches[i];
          var index = patch.index;

          while (index === low) {
              var patchType = patch.type;

              if (patchType === "p-thunk") {
                  addDomNodes(domNode, vNode.node, patch.data, eventNode);
              } else if (patchType === "p-reorder") {
                  patch.domNode = domNode;
                  patch.eventNode = eventNode;

                  var subPatches = patch.data.patches;
                  if (subPatches.length > 0) {
                      addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
                  }
              } else if (patchType === "p-remove") {
                  patch.domNode = domNode;
                  patch.eventNode = eventNode;

                  var data = patch.data;
                  if (typeof data !== "undefined") {
                      data.entry.data = domNode;
                      var subPatches = data.patches;
                      if (subPatches.length > 0) {
                          addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
                      }
                  }
              } else {
                  patch.domNode = domNode;
                  patch.eventNode = eventNode;
              }

              i++;

              if (!(patch = patches[i]) || (index = patch.index) > high) {
                  return i;
              }
          }

          switch (vNode.type) {
              case "tagger":
                  var subNode = vNode.node;

                  while (subNode.type === "tagger") {
                      subNode = subNode.node;
                  }

                  return addDomNodesHelp(
                      domNode,
                      subNode,
                      patches,
                      i,
                      low + 1,
                      high,
                      domNode.elm_event_node_ref
                  );

              case "node":
                  var vChildren = vNode.children;
                  var childNodes = domNode.childNodes;
                  for (var j = 0; j < vChildren.length; j++) {
                      low++;
                      var vChild = vChildren[j];
                      var nextLow = low + (vChild.descendantsCount || 0);
                      if (low <= index && index <= nextLow) {
                          i = addDomNodesHelp(
                              childNodes[j],
                              vChild,
                              patches,
                              i,
                              low,
                              nextLow,
                              eventNode
                          );
                          if (!(patch = patches[i]) || (index = patch.index) > high) {
                              return i;
                          }
                      }
                      low = nextLow;
                  }
                  return i;

              case "keyed-node":
                  var vChildren = vNode.children;
                  var childNodes = domNode.childNodes;
                  for (var j = 0; j < vChildren.length; j++) {
                      low++;
                      var vChild = vChildren[j].value1;
                      var nextLow = low + (vChild.descendantsCount || 0);
                      if (low <= index && index <= nextLow) {
                          i = addDomNodesHelp(
                              childNodes[j],
                              vChild,
                              patches,
                              i,
                              low,
                              nextLow,
                              eventNode
                          );
                          if (!(patch = patches[i]) || (index = patch.index) > high) {
                              return i;
                          }
                      }
                      low = nextLow;
                  }
                  return i;

              case "text":
              case "thunk":
                  throw new Error("should never traverse `text` or `thunk` nodes like this");
          }
      }

      ////////////  APPLY PATCHES  ////////////

      function applyPatches(rootDomNode, oldVirtualNode, patches, eventNode) {
          if (patches.length === 0) {
              return rootDomNode;
          }

          addDomNodes(rootDomNode, oldVirtualNode, patches, eventNode);
          return applyPatchesHelp(rootDomNode, patches);
      }

      function applyPatchesHelp(rootDomNode, patches) {
          for (var i = 0; i < patches.length; i++) {
              var patch = patches[i];
              var localDomNode = patch.domNode;
              var newNode = applyPatch(localDomNode, patch);
              if (localDomNode === rootDomNode) {
                  rootDomNode = newNode;
              }
          }
          return rootDomNode;
      }

      function applyPatch(domNode, patch) {
          switch (patch.type) {
              case "p-redraw":
                  return applyPatchRedraw(domNode, patch.data, patch.eventNode);

              case "p-facts":
                  applyFacts(domNode, patch.eventNode, patch.data);
                  return domNode;

              case "p-text":
                  domNode.replaceData(0, domNode.length, patch.data);
                  return domNode;

              case "p-thunk":
                  return applyPatchesHelp(domNode, patch.data);

              case "p-tagger":
                  if (typeof domNode.elm_event_node_ref !== "undefined") {
                      domNode.elm_event_node_ref.tagger = patch.data;
                  } else {
                      domNode.elm_event_node_ref = { tagger: patch.data, parent: patch.eventNode };
                  }
                  return domNode;

              case "p-remove-last":
                  var i = patch.data;
                  while (i--) {
                      domNode.removeChild(domNode.lastChild);
                  }
                  return domNode;

              case "p-append":
                  var newNodes = patch.data;
                  for (var i = 0; i < newNodes.length; i++) {
                      domNode.appendChild(render(newNodes[i], patch.eventNode));
                  }
                  return domNode;

              case "p-remove":
                  var data = patch.data;
                  if (typeof data === "undefined") {
                      domNode.parentNode.removeChild(domNode);
                      return domNode;
                  }
                  var entry = data.entry;
                  if (typeof entry.index !== "undefined") {
                      domNode.parentNode.removeChild(domNode);
                  }
                  entry.data = applyPatchesHelp(domNode, data.patches);
                  return domNode;

              case "p-reorder":
                  return applyPatchReorder(domNode, patch);

              case "p-custom":
                  var impl = patch.data;
                  return impl.applyPatch(domNode, impl.data);

              default:
                  throw new Error("Ran into an unknown patch!");
          }
      }

      function applyPatchRedraw(domNode, vNode, eventNode) {
          var parentNode = domNode.parentNode;
          var newNode = render(vNode, eventNode);

          if (typeof newNode.elm_event_node_ref === "undefined") {
              newNode.elm_event_node_ref = domNode.elm_event_node_ref;
          }

          if (parentNode && newNode !== domNode) {
              parentNode.replaceChild(newNode, domNode);
          }
          return newNode;
      }

      function applyPatchReorder(domNode, patch) {
          var data = patch.data;

          // remove end inserts
          var frag = applyPatchReorderEndInsertsHelp(data.endInserts, patch);

          // removals
          domNode = applyPatchesHelp(domNode, data.patches);

          // inserts
          var inserts = data.inserts;
          for (var i = 0; i < inserts.length; i++) {
              var insert = inserts[i];
              var entry = insert.entry;
              var node = entry.tag === "move" ? entry.data : render(entry.vnode, patch.eventNode);
              domNode.insertBefore(node, domNode.childNodes[insert.index]);
          }

          // add end inserts
          if (typeof frag !== "undefined") {
              domNode.appendChild(frag);
          }

          return domNode;
      }

      function applyPatchReorderEndInsertsHelp(endInserts, patch) {
          if (typeof endInserts === "undefined") {
              return;
          }

          var frag = localDoc.createDocumentFragment();
          for (var i = 0; i < endInserts.length; i++) {
              var insert = endInserts[i];
              var entry = insert.entry;
              frag.appendChild(
                  entry.tag === "move" ? entry.data : render(entry.vnode, patch.eventNode)
              );
          }
          return frag;
      }

      // PROGRAMS

      var program = makeProgram(checkNoFlags);
      var programWithFlags = makeProgram(checkYesFlags);

      function makeProgram(flagChecker) {
          return F2(function(debugWrap, impl) {
              return function(flagDecoder) {
                  return function(object, moduleName, debugMetadata) {
                      var checker = flagChecker(flagDecoder, moduleName);
                      if (typeof debugMetadata === "undefined") {
                          normalSetup(impl, object, moduleName, checker);
                      } else {
                          debugSetup(A2(debugWrap, debugMetadata, impl), object, moduleName, checker);
                      }
                  };
              };
          });
      }

      function staticProgram(vNode) {
          var nothing = _elm_lang$core$Native_Utils.Tuple2(
              _elm_lang$core$Native_Utils.Tuple0,
              _elm_lang$core$Platform_Cmd$none
          );
          return A2(program, _elm_lang$virtual_dom$VirtualDom_Debug$wrap, {
              init: nothing,
              view: function() {
                  return vNode;
              },
              update: F2(function() {
                  return nothing;
              }),
              subscriptions: function() {
                  return _elm_lang$core$Platform_Sub$none;
              }
          })();
      }

      // FLAG CHECKERS

      function checkNoFlags(flagDecoder, moduleName) {
          return function(init, flags, domNode) {
              if (typeof flags === "undefined") {
                  return init;
              }

              var errorMessage =
                  "The `" +
                  moduleName +
                  "` module does not need flags.\n" +
                  "Initialize it with no arguments and you should be all set!";

              crash(errorMessage, domNode);
          };
      }

      function checkYesFlags(flagDecoder, moduleName) {
          return function(init, flags, domNode) {
              if (typeof flagDecoder === "undefined") {
                  var errorMessage =
                      "Are you trying to sneak a Never value into Elm? Trickster!\n" +
                      "It looks like " +
                      moduleName +
                      ".main is defined with `programWithFlags` but has type `Program Never`.\n" +
                      "Use `program` instead if you do not want flags.";

                  crash(errorMessage, domNode);
              }

              var result = A2(window._elm_lang$core$Native_Json.run, flagDecoder, flags);
              if (result.ctor === "Ok") {
                  return init(result.value0);
              }

              var errorMessage =
                  "Trying to initialize the `" +
                  moduleName +
                  "` module with an unexpected flag.\n" +
                  "I tried to convert it to an Elm value, but ran into this problem:\n\n" +
                  result.value0;

              crash(errorMessage, domNode);
          };
      }

      function crash(errorMessage, domNode) {
          if (domNode) {
              domNode.innerHTML =
                  '<div style="padding-left:1em;">' +
                  '<h2 style="font-weight:normal;"><b>Oops!</b> Something went wrong when starting your Elm program.</h2>' +
                  '<pre style="padding-left:1em;">' +
                  errorMessage +
                  "</pre>" +
                  "</div>";
          }

          throw new Error(errorMessage);
      }

      //  NORMAL SETUP

      function normalSetup(impl, object, moduleName, flagChecker) {
          object["embed"] = function embed(node, flags) {
              while (node.lastChild) {
                  node.removeChild(node.lastChild);
              }

              return _elm_lang$core$Native_Platform.initialize(
                  flagChecker(impl.init, flags, node),
                  impl.update,
                  impl.subscriptions,
                  normalRenderer(node, impl.view)
              );
          };

          object["fullscreen"] = function fullscreen(flags) {
              return _elm_lang$core$Native_Platform.initialize(
                  flagChecker(impl.init, flags, document.body),
                  impl.update,
                  impl.subscriptions,
                  normalRenderer(document.body, impl.view)
              );
          };
      }

      function normalRenderer(parentNode, view) {
          return function(tagger, initialModel) {
              var eventNode = { tagger: tagger, parent: undefined };
              var initialVirtualNode = view(initialModel);
              var domNode = render(initialVirtualNode, eventNode);
              parentNode.appendChild(domNode);
              return makeStepper(domNode, view, initialVirtualNode, eventNode);
          };
      }

      // STEPPER

      var rAF =
          typeof requestAnimationFrame !== "undefined"
              ? requestAnimationFrame
              : function(callback) {
                    setTimeout(callback, 1000 / 60);
                };

      function makeStepper(domNode, view, initialVirtualNode, eventNode) {
          var state = "NO_REQUEST";
          var currNode = initialVirtualNode;
          var nextModel;

          function updateIfNeeded() {
              switch (state) {
                  case "NO_REQUEST":
                      throw new Error(
                          "Unexpected draw callback.\n" +
                              "Please report this to <https://github.com/elm-lang/virtual-dom/issues>.")
                       ;

                  case "PENDING_REQUEST":
                      rAF(updateIfNeeded);
                      state = "EXTRA_REQUEST";

                      var nextNode = view(nextModel);
                      var patches = diff(currNode, nextNode);
                      domNode = applyPatches(domNode, currNode, patches, eventNode);
                      currNode = nextNode;

                      return;

                  case "EXTRA_REQUEST":
                      state = "NO_REQUEST";
                      return;
              }
          }

          return function stepper(model) {
              if (state === "NO_REQUEST") {
                  rAF(updateIfNeeded);
              }
              state = "PENDING_REQUEST";
              nextModel = model;
          };
      }

      // DEBUG SETUP

      function debugSetup(impl, object, moduleName, flagChecker) {
          object["fullscreen"] = function fullscreen(flags) {
              var popoutRef = { doc: undefined };
              return _elm_lang$core$Native_Platform.initialize(
                  flagChecker(impl.init, flags, document.body),
                  impl.update(scrollTask(popoutRef)),
                  impl.subscriptions,
                  debugRenderer(
                      moduleName,
                      document.body,
                      popoutRef,
                      impl.view,
                      impl.viewIn,
                      impl.viewOut
                  )
              );
          };

          object["embed"] = function fullscreen(node, flags) {
              var popoutRef = { doc: undefined };
              return _elm_lang$core$Native_Platform.initialize(
                  flagChecker(impl.init, flags, node),
                  impl.update(scrollTask(popoutRef)),
                  impl.subscriptions,
                  debugRenderer(moduleName, node, popoutRef, impl.view, impl.viewIn, impl.viewOut)
              );
          };
      }

      function scrollTask(popoutRef) {
          return _elm_lang$core$Native_Scheduler.nativeBinding(function(callback) {
              var doc = popoutRef.doc;
              if (doc) {
                  var msgs = doc.getElementsByClassName("debugger-sidebar-messages")[0];
                  if (msgs) {
                      msgs.scrollTop = msgs.scrollHeight;
                  }
              }
              callback(_elm_lang$core$Native_Scheduler.succeed(_elm_lang$core$Native_Utils.Tuple0));
          });
      }

      function debugRenderer(moduleName, parentNode, popoutRef, view, viewIn, viewOut) {
          return function(tagger, initialModel) {
              var appEventNode = { tagger: tagger, parent: undefined };
              var eventNode = { tagger: tagger, parent: undefined };

              // make normal stepper
              var appVirtualNode = view(initialModel);
              var appNode = render(appVirtualNode, appEventNode);
              parentNode.appendChild(appNode);
              var appStepper = makeStepper(appNode, view, appVirtualNode, appEventNode);

              // make overlay stepper
              var overVirtualNode = viewIn(initialModel).value1;
              var overNode = render(overVirtualNode, eventNode);
              parentNode.appendChild(overNode);
              var wrappedViewIn = wrapViewIn(appEventNode, overNode, viewIn);
              var overStepper = makeStepper(overNode, wrappedViewIn, overVirtualNode, eventNode);

              // make debugger stepper
              var debugStepper = makeDebugStepper(
                  initialModel,
                  viewOut,
                  eventNode,
                  parentNode,
                  moduleName,
                  popoutRef
              );

              return function stepper(model) {
                  appStepper(model);
                  overStepper(model);
                  debugStepper(model);
              };
          };
      }

      function makeDebugStepper(initialModel, view, eventNode, parentNode, moduleName, popoutRef) {
          var curr;
          var domNode;

          return function stepper(model) {
              if (!model.isDebuggerOpen) {
                  return;
              }

              if (!popoutRef.doc) {
                  curr = view(model);
                  domNode = openDebugWindow(moduleName, popoutRef, curr, eventNode);
                  return;
              }

              // switch to document of popout
              localDoc = popoutRef.doc;

              var next = view(model);
              var patches = diff(curr, next);
              domNode = applyPatches(domNode, curr, patches, eventNode);
              curr = next;

              // switch back to normal document
              localDoc = document;
          };
      }

      function openDebugWindow(moduleName, popoutRef, virtualNode, eventNode) {
          var w = 900;
          var h = 360;
          var x = screen.width - w;
          var y = screen.height - h;
          var debugWindow = window.open(
              "",
              "",
              "width=" + w + ",height=" + h + ",left=" + x + ",top=" + y
          );

          // switch to window document
          localDoc = debugWindow.document;

          popoutRef.doc = localDoc;
          localDoc.title = "Debugger - " + moduleName;
          localDoc.body.style.margin = "0";
          localDoc.body.style.padding = "0";
          var domNode = render(virtualNode, eventNode);
          localDoc.body.appendChild(domNode);

          localDoc.addEventListener("keydown", function(event) {
              if (event.metaKey && event.which === 82) {
                  window.location.reload();
              }
              if (event.which === 38) {
                  eventNode.tagger({ ctor: "Up" });
                  event.preventDefault();
              }
              if (event.which === 40) {
                  eventNode.tagger({ ctor: "Down" });
                  event.preventDefault();
              }
          });

          function close() {
              popoutRef.doc = undefined;
              debugWindow.close();
          }
          window.addEventListener("unload", close);
          debugWindow.addEventListener("unload", function() {
              popoutRef.doc = undefined;
              window.removeEventListener("unload", close);
              eventNode.tagger({ ctor: "Close" });
          });

          // switch back to the normal document
          localDoc = document;

          return domNode;
      }

      // BLOCK EVENTS

      function wrapViewIn(appEventNode, overlayNode, viewIn) {
          var ignorer = makeIgnorer(overlayNode);
          var blocking = "Normal";
          var overflow;

          var normalTagger = appEventNode.tagger;
          var blockTagger = function() {};

          return function(model) {
              var tuple = viewIn(model);
              var newBlocking = tuple.value0.ctor;
              appEventNode.tagger = newBlocking === "Normal" ? normalTagger : blockTagger;
              if (blocking !== newBlocking) {
                  traverse("removeEventListener", ignorer, blocking);
                  traverse("addEventListener", ignorer, newBlocking);

                  if (blocking === "Normal") {
                      overflow = document.body.style.overflow;
                      document.body.style.overflow = "hidden";
                  }

                  if (newBlocking === "Normal") {
                      document.body.style.overflow = overflow;
                  }

                  blocking = newBlocking;
              }
              return tuple.value1;
          };
      }

      function traverse(verbEventListener, ignorer, blocking) {
          switch (blocking) {
              case "Normal":
                  return;

              case "Pause":
                  return traverseHelp(verbEventListener, ignorer, mostEvents);

              case "Message":
                  return traverseHelp(verbEventListener, ignorer, allEvents);
          }
      }

      function traverseHelp(verbEventListener, handler, eventNames) {
          for (var i = 0; i < eventNames.length; i++) {
              document.body[verbEventListener](eventNames[i], handler, true);
          }
      }

      function makeIgnorer(overlayNode) {
          return function(event) {
              if (event.type === "keydown" && event.metaKey && event.which === 82) {
                  return;
              }

              var isScroll = event.type === "scroll" || event.type === "wheel";

              var node = event.target;
              while (node !== null) {
                  if (node.className === "elm-overlay-message-details" && isScroll) {
                      return;
                  }

                  if (node === overlayNode && !isScroll) {
                      return;
                  }
                  node = node.parentNode;
              }

              event.stopPropagation();
              event.preventDefault();
          };
      }

      var mostEvents = [
          "click",
          "dblclick",
          "mousemove",
          "mouseup",
          "mousedown",
          "mouseenter",
          "mouseleave",
          "touchstart",
          "touchend",
          "touchcancel",
          "touchmove",
          "pointerdown",
          "pointerup",
          "pointerover",
          "pointerout",
          "pointerenter",
          "pointerleave",
          "pointermove",
          "pointercancel",
          "dragstart",
          "drag",
          "dragend",
          "dragenter",
          "dragover",
          "dragleave",
          "drop",
          "keyup",
          "keydown",
          "keypress",
          "input",
          "change",
          "focus",
          "blur"
      ];

      var allEvents = mostEvents.concat("wheel", "scroll");

      return {
          node: node,
          text: text,
          custom: custom,
          map: F2(map),

          onWithOptions: F3(on),
          style: style,
          property: F2(property),
          attribute: F2(attribute),
          attributeNS: F3(attributeNS),
          mapProperty: F2(mapProperty),

          lazy: F2(lazy),
          lazy2: F3(lazy2),
          lazy3: F4(lazy3),
          keyedNode: F3(keyedNode),

          program: program,
          programWithFlags: programWithFlags,
          staticProgram: staticProgram,

          // Extra exposition
          normalRenderer: normalRenderer
      };
  })();

  var vdom = _elm_lang$virtual_dom$Native_VirtualDom;
  exports.text = vdom.text;                  
  exports.style = vdom.style;
  exports.property = vdom.property;
  exports.attribute = vdom.attribute;
  exports.attributeNS = vdom.attributeNS;
  exports.mapProperty = vdom.mapProperty;

  exports.lazy = vdom.lazy;
  exports.lazy2 = vdom.lazy2;
  exports.lazy3 = vdom.lazy3;         

  // exports.program = vdom.program;
  // exports.programWithFlags = vdom.programWithFlags;
  // exports.staticProgram = vdom.staticProgram;
  exports.normalRenderer = vdom.normalRenderer;
})(PS["Elm.Native.VirtualDom"] = PS["Elm.Native.VirtualDom"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Elm.Native.VirtualDom"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor = PS["Data.Functor"];
  var Data_List = PS["Data.List"];
  var Data_Tuple = PS["Data.Tuple"];
  var Elm_Json_Decode = PS["Elm.Json.Decode"];
  var Elm_Json_Encode = PS["Elm.Json.Encode"];
  var Prelude = PS["Prelude"];
  exports["normalRenderer"] = $foreign.normalRenderer;
  exports["text"] = $foreign.text;
})(PS["Elm.Native.VirtualDom"] = PS["Elm.Native.VirtualDom"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Elm.Native.Platform"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Tuple = PS["Data.Tuple"];
  var Elm_Cmd = PS["Elm.Cmd"];
  var Elm_Native_Scheduler = PS["Elm.Native.Scheduler"];
  var Elm_Native_VirtualDom = PS["Elm.Native.VirtualDom"];
  var Prelude = PS["Prelude"];
  exports["program"] = $foreign.program;
})(PS["Elm.Native.Platform"] = PS["Elm.Native.Platform"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Tuple = PS["Data.Tuple"];
  var Elm_Cmd = PS["Elm.Cmd"];
  var Elm_Native_Platform = PS["Elm.Native.Platform"];
  var Elm_Native_Scheduler = PS["Elm.Native.Scheduler"];
  var Elm_Native_VirtualDom = PS["Elm.Native.VirtualDom"];
  var Elm_Operators = PS["Elm.Operators"];
  var Prelude = PS["Prelude"];        
  var text = Elm_Native_VirtualDom.text;
  var program = function (v) {
      return Elm_Native_Platform.program(Elm_Native_Scheduler.scheduler)(Elm_Native_VirtualDom.normalRenderer)(v.init)(v.update)(v.view);
  };
  exports["text"] = text;
  exports["program"] = program;
})(PS["Elm.Html"] = PS["Elm.Html"] || {});
(function(exports) {exports.setStorage = function(model) {
      return function() {};
  };

  exports.focusElement = function(id) {
      return function() {};
  };
})(PS["Main"] = PS["Main"] || {});
(function(exports) {
  // Generated by purs version 0.11.7
  "use strict";
  var $foreign = PS["Main"];
  var Control_Monad_Cont_Trans = PS["Control.Monad.Cont.Trans"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_String = PS["Data.String"];
  var Data_Tuple = PS["Data.Tuple"];
  var Elm_Cmd = PS["Elm.Cmd"];
  var Elm_Html = PS["Elm.Html"];
  var Elm_Html_Attributes = PS["Elm.Html.Attributes"];
  var Elm_Html_Events = PS["Elm.Html.Events"];
  var Elm_Html_Keyed = PS["Elm.Html.Keyed"];
  var Elm_Html_Lazy = PS["Elm.Html.Lazy"];
  var Elm_Json_Decode = PS["Elm.Json.Decode"];
  var Elm_Operators = PS["Elm.Operators"];
  var Prelude = PS["Prelude"];        
  var NoOp = (function () {
      function NoOp() {

      };
      NoOp.value = new NoOp();
      return NoOp;
  })();
  var UpdateField = (function () {
      function UpdateField(value0) {
          this.value0 = value0;
      };
      UpdateField.create = function (value0) {
          return new UpdateField(value0);
      };
      return UpdateField;
  })();
  var EditingEntry = (function () {
      function EditingEntry(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      EditingEntry.create = function (value0) {
          return function (value1) {
              return new EditingEntry(value0, value1);
          };
      };
      return EditingEntry;
  })();
  var UpdateEntry = (function () {
      function UpdateEntry(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      UpdateEntry.create = function (value0) {
          return function (value1) {
              return new UpdateEntry(value0, value1);
          };
      };
      return UpdateEntry;
  })();
  var Add = (function () {
      function Add() {

      };
      Add.value = new Add();
      return Add;
  })();
  var Delete = (function () {
      function Delete(value0) {
          this.value0 = value0;
      };
      Delete.create = function (value0) {
          return new Delete(value0);
      };
      return Delete;
  })();
  var DeleteComplete = (function () {
      function DeleteComplete() {

      };
      DeleteComplete.value = new DeleteComplete();
      return DeleteComplete;
  })();
  var Check = (function () {
      function Check(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Check.create = function (value0) {
          return function (value1) {
              return new Check(value0, value1);
          };
      };
      return Check;
  })();
  var CheckAll = (function () {
      function CheckAll(value0) {
          this.value0 = value0;
      };
      CheckAll.create = function (value0) {
          return new CheckAll(value0);
      };
      return CheckAll;
  })();
  var ChangeVisibility = (function () {
      function ChangeVisibility(value0) {
          this.value0 = value0;
      };
      ChangeVisibility.create = function (value0) {
          return new ChangeVisibility(value0);
      };
      return ChangeVisibility;
  })();
  var view = function (model) {
      return Elm_Html.text("Testing");
  };
  var newEntry = function (desc) {
      return function (id) {
          return {
              description: desc,
              completed: false,
              editing: false,
              id: id
          };
      };
  };
  var update = function (msg) {
      return function (model) {
          if (msg instanceof NoOp) {
              return new Data_Tuple.Tuple(model, [  ]);
          };
          if (msg instanceof Add) {
              return new Data_Tuple.Tuple((function () {
                  var $16 = {};
                  for (var $17 in model) {
                      if ({}.hasOwnProperty.call(model, $17)) {
                          $16[$17] = model[$17];
                      };
                  };
                  $16.uid = model.uid + 1 | 0;
                  $16.field = "";
                  $16.entries = (function () {
                      var $15 = Data_String["null"](model.field);
                      if ($15) {
                          return model.entries;
                      };
                      return new Data_List_Types.Cons(newEntry(model.field)(model.uid), model.entries);
                  })();
                  return $16;
              })(), [  ]);
          };
          if (msg instanceof UpdateField) {
              return new Data_Tuple.Tuple((function () {
                  var $19 = {};
                  for (var $20 in model) {
                      if ({}.hasOwnProperty.call(model, $20)) {
                          $19[$20] = model[$20];
                      };
                  };
                  $19.field = msg.value0;
                  return $19;
              })(), [  ]);
          };
          if (msg instanceof EditingEntry) {
              var updateEntry = function (t) {
                  var $23 = t.id === msg.value0;
                  if ($23) {
                      var $24 = {};
                      for (var $25 in t) {
                          if ({}.hasOwnProperty.call(t, $25)) {
                              $24[$25] = t[$25];
                          };
                      };
                      $24.editing = msg.value1;
                      return $24;
                  };
                  return t;
              };
              var focus = $foreign.focusElement("todo-" + Data_Show.show(Data_Show.showInt)(msg.value0));
              return new Data_Tuple.Tuple((function () {
                  var $27 = {};
                  for (var $28 in model) {
                      if ({}.hasOwnProperty.call(model, $28)) {
                          $27[$28] = model[$28];
                      };
                  };
                  $27.entries = Data_Functor.map(Data_List_Types.functorList)(updateEntry)(model.entries);
                  return $27;
              })(), [ Control_Monad_Eff_Class.liftEff(Control_Monad_Cont_Trans.monadEffContT(Control_Monad_Eff_Class.monadEffEff))(focus) ]);
          };
          if (msg instanceof UpdateEntry) {
              var updateEntry = function (t) {
                  var $32 = t.id === msg.value0;
                  if ($32) {
                      var $33 = {};
                      for (var $34 in t) {
                          if ({}.hasOwnProperty.call(t, $34)) {
                              $33[$34] = t[$34];
                          };
                      };
                      $33.description = msg.value1;
                      return $33;
                  };
                  return t;
              };
              return new Data_Tuple.Tuple((function () {
                  var $36 = {};
                  for (var $37 in model) {
                      if ({}.hasOwnProperty.call(model, $37)) {
                          $36[$37] = model[$37];
                      };
                  };
                  $36.entries = Data_Functor.map(Data_List_Types.functorList)(updateEntry)(model.entries);
                  return $36;
              })(), [  ]);
          };
          if (msg instanceof Delete) {
              return new Data_Tuple.Tuple((function () {
                  var $41 = {};
                  for (var $42 in model) {
                      if ({}.hasOwnProperty.call(model, $42)) {
                          $41[$42] = model[$42];
                      };
                  };
                  $41.entries = Data_List.filter(function (t) {
                      return t.id !== msg.value0;
                  })(model.entries);
                  return $41;
              })(), [  ]);
          };
          if (msg instanceof DeleteComplete) {
              return new Data_Tuple.Tuple((function () {
                  var $45 = {};
                  for (var $46 in model) {
                      if ({}.hasOwnProperty.call(model, $46)) {
                          $45[$46] = model[$46];
                      };
                  };
                  $45.entries = Data_List.filter(function ($71) {
                      return !(function (v1) {
                          return v1.completed;
                      })($71);
                  })(model.entries);
                  return $45;
              })(), [  ]);
          };
          if (msg instanceof Check) {
              var updateEntry = function (t) {
                  var $48 = t.id === msg.value0;
                  if ($48) {
                      var $49 = {};
                      for (var $50 in t) {
                          if ({}.hasOwnProperty.call(t, $50)) {
                              $49[$50] = t[$50];
                          };
                      };
                      $49.completed = msg.value1;
                      return $49;
                  };
                  return t;
              };
              return new Data_Tuple.Tuple((function () {
                  var $52 = {};
                  for (var $53 in model) {
                      if ({}.hasOwnProperty.call(model, $53)) {
                          $52[$53] = model[$53];
                      };
                  };
                  $52.entries = Data_Functor.map(Data_List_Types.functorList)(updateEntry)(model.entries);
                  return $52;
              })(), [  ]);
          };
          if (msg instanceof CheckAll) {
              var updateEntry = function (t) {
                  var $57 = {};
                  for (var $58 in t) {
                      if ({}.hasOwnProperty.call(t, $58)) {
                          $57[$58] = t[$58];
                      };
                  };
                  $57.completed = msg.value0;
                  return $57;
              };
              return new Data_Tuple.Tuple((function () {
                  var $60 = {};
                  for (var $61 in model) {
                      if ({}.hasOwnProperty.call(model, $61)) {
                          $60[$61] = model[$61];
                      };
                  };
                  $60.entries = Data_Functor.map(Data_List_Types.functorList)(updateEntry)(model.entries);
                  return $60;
              })(), [  ]);
          };
          if (msg instanceof ChangeVisibility) {
              return new Data_Tuple.Tuple((function () {
                  var $64 = {};
                  for (var $65 in model) {
                      if ({}.hasOwnProperty.call(model, $65)) {
                          $64[$65] = model[$65];
                      };
                  };
                  $64.visibility = msg.value0;
                  return $64;
              })(), [  ]);
          };
          throw new Error("Failed pattern match at Main line 132, column 5 - line 205, column 51: " + [ msg.constructor.name ]);
      };
  };
  var updateWithStorage = function (msg) {
      return function (model) {
          var v = update(msg)(model);
          return new Data_Tuple.Tuple(v.value0, Data_Semigroup.append(Data_Semigroup.semigroupArray)(v.value1)([ Control_Monad_Eff_Class.liftEff(Control_Monad_Cont_Trans.monadEffContT(Control_Monad_Eff_Class.monadEffEff))($foreign.setStorage(v.value0)) ]));
      };
  };
  var emptyModel = {
      entries: Data_Monoid.mempty(Data_List_Types.monoidList),
      visibility: "All",
      field: "",
      uid: 0
  };
  var init = new Data_Tuple.Tuple(emptyModel, [  ]);
  var main = Elm_Html.program({
      init: init,
      update: updateWithStorage,
      view: view
  });
  exports["main"] = main;
  exports["updateWithStorage"] = updateWithStorage;
  exports["emptyModel"] = emptyModel;
  exports["newEntry"] = newEntry;
  exports["init"] = init;
  exports["NoOp"] = NoOp;
  exports["UpdateField"] = UpdateField;
  exports["EditingEntry"] = EditingEntry;
  exports["UpdateEntry"] = UpdateEntry;
  exports["Add"] = Add;
  exports["Delete"] = Delete;
  exports["DeleteComplete"] = DeleteComplete;
  exports["Check"] = Check;
  exports["CheckAll"] = CheckAll;
  exports["ChangeVisibility"] = ChangeVisibility;
  exports["update"] = update;
  exports["view"] = view;
  exports["setStorage"] = $foreign.setStorage;
  exports["focusElement"] = $foreign.focusElement;
})(PS["Main"] = PS["Main"] || {});
PS["Main"].main();
